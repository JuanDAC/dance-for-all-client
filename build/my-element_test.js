
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
import { MyElement } from './my-element.js';
import { y, b, x, Z } from './query-assigned-elements-c9e89c8d.js';
import './property-e4014f26.js';

var e$3="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};function t$1(e){throw new Error('Could not dynamically require "'+e+'". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')}var o$1=function(){function e(n,o,r){function i(a,c){if(!o[a]){if(!n[a]){if(!c&&t$1)return t$1(a);if(s)return s(a,!0);var u=new Error("Cannot find module '"+a+"'");throw u.code="MODULE_NOT_FOUND",u}var f=o[a]={exports:{}};n[a][0].call(f.exports,(function(e){return i(n[a][1][e]||e)}),f,f.exports,e,n,o,r);}return o[a].exports}for(var s=t$1,a=0;a<r.length;a++)i(r[a]);return i}return e}()({1:[function(e,t,n){t.exports=e("./lib/chai");},{"./lib/chai":2}],2:[function(e,t,n){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var o=[];
/*!
 * Chai version
 */n.version="4.3.3",
/*!
 * Assertion Error
 */
n.AssertionError=e("assertion-error");
/*!
 * Utils for plugins (not exported)
 */
var r=e("./chai/utils");n.use=function(e){return ~o.indexOf(e)||(e(n,r),o.push(e)),n},
/*!
 * Utility Functions
 */
n.util=r;
/*!
 * Configuration
 */
var i=e("./chai/config");n.config=i;
/*!
 * Primary `Assertion` prototype
 */
var s=e("./chai/assertion");n.use(s);
/*!
 * Core Assertions
 */
var a=e("./chai/core/assertions");n.use(a);
/*!
 * Expect interface
 */
var c=e("./chai/interface/expect");n.use(c);
/*!
 * Should interface
 */
var u=e("./chai/interface/should");n.use(u);
/*!
 * Assert interface
 */
var f=e("./chai/interface/assert");n.use(f);},{"./chai/assertion":3,"./chai/config":4,"./chai/core/assertions":5,"./chai/interface/assert":6,"./chai/interface/expect":7,"./chai/interface/should":8,"./chai/utils":23,"assertion-error":34}],3:[function(e,t,n){
/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var o=e("./config");t.exports=function(e,t){
/*!
   * Module dependencies.
   */
var n=e.AssertionError,r=t.flag;
/*!
   * Module export.
   */
/*!
   * Assertion Constructor
   *
   * Creates object for chaining.
   *
   * `Assertion` objects contain metadata in the form of flags. Three flags can
   * be assigned during instantiation by passing arguments to this constructor:
   *
   * - `object`: This flag contains the target of the assertion. For example, in
   *   the assertion `expect(numKittens).to.equal(7);`, the `object` flag will
   *   contain `numKittens` so that the `equal` assertion can reference it when
   *   needed.
   *
   * - `message`: This flag contains an optional custom error message to be
   *   prepended to the error message that's generated by the assertion when it
   *   fails.
   *
   * - `ssfi`: This flag stands for "start stack function indicator". It
   *   contains a function reference that serves as the starting point for
   *   removing frames from the stack trace of the error that's created by the
   *   assertion when it fails. The goal is to provide a cleaner stack trace to
   *   end users by removing Chai's internal functions. Note that it only works
   *   in environments that support `Error.captureStackTrace`, and only when
   *   `Chai.config.includeStack` hasn't been set to `false`.
   *
   * - `lockSsfi`: This flag controls whether or not the given `ssfi` flag
   *   should retain its current value, even as assertions are chained off of
   *   this object. This is usually set to `true` when creating a new assertion
   *   from within another assertion. It's also temporarily set to `true` before
   *   an overwritten assertion gets called by the overwriting assertion.
   *
   * @param {Mixed} obj target of the assertion
   * @param {String} msg (optional) custom error message
   * @param {Function} ssfi (optional) starting point for removing stack frames
   * @param {Boolean} lockSsfi (optional) whether or not the ssfi flag is locked
   * @api private
   */
function i(e,n,o,s){return r(this,"ssfi",o||i),r(this,"lockSsfi",s),r(this,"object",e),r(this,"message",n),t.proxify(this)}e.Assertion=i,Object.defineProperty(i,"includeStack",{get:function(){return console.warn("Assertion.includeStack is deprecated, use chai.config.includeStack instead."),o.includeStack},set:function(e){console.warn("Assertion.includeStack is deprecated, use chai.config.includeStack instead."),o.includeStack=e;}}),Object.defineProperty(i,"showDiff",{get:function(){return console.warn("Assertion.showDiff is deprecated, use chai.config.showDiff instead."),o.showDiff},set:function(e){console.warn("Assertion.showDiff is deprecated, use chai.config.showDiff instead."),o.showDiff=e;}}),i.addProperty=function(e,n){t.addProperty(this.prototype,e,n);},i.addMethod=function(e,n){t.addMethod(this.prototype,e,n);},i.addChainableMethod=function(e,n,o){t.addChainableMethod(this.prototype,e,n,o);},i.overwriteProperty=function(e,n){t.overwriteProperty(this.prototype,e,n);},i.overwriteMethod=function(e,n){t.overwriteMethod(this.prototype,e,n);},i.overwriteChainableMethod=function(e,n,o){t.overwriteChainableMethod(this.prototype,e,n,o);},i.prototype.assert=function(e,i,s,a,c,u){var f=t.test(this,arguments);if(!1!==u&&(u=!0),void 0===a&&void 0===c&&(u=!1),!0!==o.showDiff&&(u=!1),!f){i=t.getMessage(this,arguments);var p={actual:t.getActual(this,arguments),expected:a,showDiff:u},l=t.getOperator(this,arguments);throw l&&(p.operator=l),new n(i,p,o.includeStack?this.assert:r(this,"ssfi"))}},
/*!
   * ### ._obj
   *
   * Quick reference to stored `actual` value for plugin developers.
   *
   * @api private
   */
Object.defineProperty(i.prototype,"_obj",{get:function(){return r(this,"object")},set:function(e){r(this,"object",e);}});};},{"./config":4}],4:[function(e,t,n){t.exports={includeStack:!1,showDiff:!0,truncateThreshold:40,useProxy:!0,proxyExcludedKeys:["then","catch","inspect","toJSON"]};},{}],5:[function(e,t,n){
/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
t.exports=function(e,t){var n=e.Assertion,o=e.AssertionError,r=t.flag;function i(e,n){n&&r(this,"message",n),e=e.toLowerCase();var o=r(this,"object"),i=~["a","e","i","o","u"].indexOf(e.charAt(0))?"an ":"a ";this.assert(e===t.type(o).toLowerCase(),"expected #{this} to be "+i+e,"expected #{this} not to be "+i+e);}function s(e,n){return t.isNaN(e)&&t.isNaN(n)||e===n}function a(){r(this,"contains",!0);}function c(e,i){i&&r(this,"message",i);var a=r(this,"object"),c=t.type(a).toLowerCase(),u=r(this,"message"),f=r(this,"negate"),p=r(this,"ssfi"),l=r(this,"deep"),h=l?"deep ":"";u=u?u+": ":"";var d=!1;switch(c){case"string":d=-1!==a.indexOf(e);break;case"weakset":if(l)throw new o(u+"unable to use .deep.include with WeakSet",void 0,p);d=a.has(e);break;case"map":var y=l?t.eql:s;a.forEach((function(t){d=d||y(t,e);}));break;case"set":l?a.forEach((function(n){d=d||t.eql(n,e);})):d=a.has(e);break;case"array":d=l?a.some((function(n){return t.eql(n,e)})):-1!==a.indexOf(e);break;default:if(e!==Object(e))throw new o(u+"the given combination of arguments ("+c+" and "+t.type(e).toLowerCase()+") is invalid for this assertion. You can use an array, a map, an object, a set, a string, or a weakset instead of a "+t.type(e).toLowerCase(),void 0,p);var b=Object.keys(e),g=null,w=0;if(b.forEach((function(i){var s=new n(a);if(t.transferFlags(this,s,!0),r(s,"lockSsfi",!0),f&&1!==b.length)try{s.property(i,e[i]);}catch(e){if(!t.checkError.compatibleConstructor(e,o))throw e;null===g&&(g=e),w++;}else s.property(i,e[i]);}),this),f&&b.length>1&&w===b.length)throw g;return}this.assert(d,"expected #{this} to "+h+"include "+t.inspect(e),"expected #{this} to not "+h+"include "+t.inspect(e));}function u(){var e=r(this,"object");this.assert(null!=e,"expected #{this} to exist","expected #{this} to not exist");}function f(){var e=r(this,"object"),n=t.type(e);this.assert("Arguments"===n,"expected #{this} to be arguments but got "+n,"expected #{this} to not be arguments");}function p(e,t){t&&r(this,"message",t);var n=r(this,"object");if(r(this,"deep")){var o=r(this,"lockSsfi");r(this,"lockSsfi",!0),this.eql(e),r(this,"lockSsfi",o);}else this.assert(e===n,"expected #{this} to equal #{exp}","expected #{this} to not equal #{exp}",e,this._obj,!0);}function l(e,n){n&&r(this,"message",n),this.assert(t.eql(e,r(this,"object")),"expected #{this} to deeply equal #{exp}","expected #{this} to not deeply equal #{exp}",e,this._obj,!0);}function h(e,i){i&&r(this,"message",i);var s,a=r(this,"object"),c=r(this,"doLength"),u=r(this,"message"),f=u?u+": ":"",p=r(this,"ssfi"),l=t.type(a).toLowerCase(),h=t.type(e).toLowerCase(),d=!0;if(c&&"map"!==l&&"set"!==l&&new n(a,u,p,!0).to.have.property("length"),c||"date"!==l||"date"===h?"number"===h||!c&&"number"!==l?c||"date"===l||"number"===l?d=!1:s=f+"expected "+("string"===l?"'"+a+"'":a)+" to be a number or a date":s=f+"the argument to above must be a number":s=f+"the argument to above must be a date",d)throw new o(s,void 0,p);if(c){var y,b="length";"map"===l||"set"===l?(b="size",y=a.size):y=a.length,this.assert(y>e,"expected #{this} to have a "+b+" above #{exp} but got #{act}","expected #{this} to not have a "+b+" above #{exp}",e,y);}else this.assert(a>e,"expected #{this} to be above #{exp}","expected #{this} to be at most #{exp}",e);}function d(e,i){i&&r(this,"message",i);var s,a=r(this,"object"),c=r(this,"doLength"),u=r(this,"message"),f=u?u+": ":"",p=r(this,"ssfi"),l=t.type(a).toLowerCase(),h=t.type(e).toLowerCase(),d=!0;if(c&&"map"!==l&&"set"!==l&&new n(a,u,p,!0).to.have.property("length"),c||"date"!==l||"date"===h?"number"===h||!c&&"number"!==l?c||"date"===l||"number"===l?d=!1:s=f+"expected "+("string"===l?"'"+a+"'":a)+" to be a number or a date":s=f+"the argument to least must be a number":s=f+"the argument to least must be a date",d)throw new o(s,void 0,p);if(c){var y,b="length";"map"===l||"set"===l?(b="size",y=a.size):y=a.length,this.assert(y>=e,"expected #{this} to have a "+b+" at least #{exp} but got #{act}","expected #{this} to have a "+b+" below #{exp}",e,y);}else this.assert(a>=e,"expected #{this} to be at least #{exp}","expected #{this} to be below #{exp}",e);}function y(e,i){i&&r(this,"message",i);var s,a=r(this,"object"),c=r(this,"doLength"),u=r(this,"message"),f=u?u+": ":"",p=r(this,"ssfi"),l=t.type(a).toLowerCase(),h=t.type(e).toLowerCase(),d=!0;if(c&&"map"!==l&&"set"!==l&&new n(a,u,p,!0).to.have.property("length"),c||"date"!==l||"date"===h?"number"===h||!c&&"number"!==l?c||"date"===l||"number"===l?d=!1:s=f+"expected "+("string"===l?"'"+a+"'":a)+" to be a number or a date":s=f+"the argument to below must be a number":s=f+"the argument to below must be a date",d)throw new o(s,void 0,p);if(c){var y,b="length";"map"===l||"set"===l?(b="size",y=a.size):y=a.length,this.assert(y<e,"expected #{this} to have a "+b+" below #{exp} but got #{act}","expected #{this} to not have a "+b+" below #{exp}",e,y);}else this.assert(a<e,"expected #{this} to be below #{exp}","expected #{this} to be at least #{exp}",e);}function b(e,i){i&&r(this,"message",i);var s,a=r(this,"object"),c=r(this,"doLength"),u=r(this,"message"),f=u?u+": ":"",p=r(this,"ssfi"),l=t.type(a).toLowerCase(),h=t.type(e).toLowerCase(),d=!0;if(c&&"map"!==l&&"set"!==l&&new n(a,u,p,!0).to.have.property("length"),c||"date"!==l||"date"===h?"number"===h||!c&&"number"!==l?c||"date"===l||"number"===l?d=!1:s=f+"expected "+("string"===l?"'"+a+"'":a)+" to be a number or a date":s=f+"the argument to most must be a number":s=f+"the argument to most must be a date",d)throw new o(s,void 0,p);if(c){var y,b="length";"map"===l||"set"===l?(b="size",y=a.size):y=a.length,this.assert(y<=e,"expected #{this} to have a "+b+" at most #{exp} but got #{act}","expected #{this} to have a "+b+" above #{exp}",e,y);}else this.assert(a<=e,"expected #{this} to be at most #{exp}","expected #{this} to be above #{exp}",e);}function g(e,n){n&&r(this,"message",n);var i=r(this,"object"),s=r(this,"ssfi"),a=r(this,"message");try{var c=i instanceof e;}catch(n){if(n instanceof TypeError)throw new o((a=a?a+": ":"")+"The instanceof assertion needs a constructor but "+t.type(e)+" was given.",void 0,s);throw n}var u=t.getName(e);null===u&&(u="an unnamed constructor"),this.assert(c,"expected #{this} to be an instance of "+u,"expected #{this} to not be an instance of "+u);}function w(e,n,i){i&&r(this,"message",i);var s=r(this,"nested"),a=r(this,"own"),c=r(this,"message"),u=r(this,"object"),f=r(this,"ssfi"),p=typeof e;if(c=c?c+": ":"",s){if("string"!==p)throw new o(c+"the argument to property must be a string when using nested syntax",void 0,f)}else if("string"!==p&&"number"!==p&&"symbol"!==p)throw new o(c+"the argument to property must be a string, number, or symbol",void 0,f);if(s&&a)throw new o(c+'The "nested" and "own" flags cannot be combined.',void 0,f);if(null==u)throw new o(c+"Target cannot be null or undefined.",void 0,f);var l,h=r(this,"deep"),d=r(this,"negate"),y=s?t.getPathInfo(u,e):null,b=s?y.value:u[e],g="";h&&(g+="deep "),a&&(g+="own "),s&&(g+="nested "),g+="property ",l=a?Object.prototype.hasOwnProperty.call(u,e):s?y.exists:t.hasProperty(u,e),d&&1!==arguments.length||this.assert(l,"expected #{this} to have "+g+t.inspect(e),"expected #{this} to not have "+g+t.inspect(e)),arguments.length>1&&this.assert(l&&(h?t.eql(n,b):n===b),"expected #{this} to have "+g+t.inspect(e)+" of #{exp}, but got #{act}","expected #{this} to not have "+g+t.inspect(e)+" of #{act}",n,b),r(this,"object",b);}function m(e,t,n){r(this,"own",!0),w.apply(this,arguments);}function v(e,n,o){"string"==typeof n&&(o=n,n=null),o&&r(this,"message",o);var i=r(this,"object"),s=Object.getOwnPropertyDescriptor(Object(i),e);s&&n?this.assert(t.eql(n,s),"expected the own property descriptor for "+t.inspect(e)+" on #{this} to match "+t.inspect(n)+", got "+t.inspect(s),"expected the own property descriptor for "+t.inspect(e)+" on #{this} to not match "+t.inspect(n),n,s,!0):this.assert(s,"expected #{this} to have an own property descriptor for "+t.inspect(e),"expected #{this} to not have an own property descriptor for "+t.inspect(e)),r(this,"object",s);}function x(){r(this,"doLength",!0);}function O(e,o){o&&r(this,"message",o);var i,s=r(this,"object"),a=t.type(s).toLowerCase(),c=r(this,"message"),u=r(this,"ssfi"),f="length";switch(a){case"map":case"set":f="size",i=s.size;break;default:new n(s,c,u,!0).to.have.property("length"),i=s.length;}this.assert(i==e,"expected #{this} to have a "+f+" of #{exp} but got #{act}","expected #{this} to not have a "+f+" of #{act}",e,i);}function j(e,t){t&&r(this,"message",t);var n=r(this,"object");this.assert(e.exec(n),"expected #{this} to match "+e,"expected #{this} not to match "+e);}function M(e){var n,i,s=r(this,"object"),a=t.type(s),c=t.type(e),u=r(this,"ssfi"),f=r(this,"deep"),p="",l=!0,h=r(this,"message"),d=(h=h?h+": ":"")+"when testing keys against an object or an array you must give a single Array|Object|String argument or multiple String arguments";if("Map"===a||"Set"===a)p=f?"deeply ":"",i=[],s.forEach((function(e,t){i.push(t);})),"Array"!==c&&(e=Array.prototype.slice.call(arguments));else {switch(i=t.getOwnEnumerableProperties(s),c){case"Array":if(arguments.length>1)throw new o(d,void 0,u);break;case"Object":if(arguments.length>1)throw new o(d,void 0,u);e=Object.keys(e);break;default:e=Array.prototype.slice.call(arguments);}e=e.map((function(e){return "symbol"==typeof e?e:String(e)}));}if(!e.length)throw new o(h+"keys required",void 0,u);var y=e.length,b=r(this,"any"),g=r(this,"all"),w=e;if(b||g||(g=!0),b&&(l=w.some((function(e){return i.some((function(n){return f?t.eql(e,n):e===n}))}))),g&&(l=w.every((function(e){return i.some((function(n){return f?t.eql(e,n):e===n}))})),r(this,"contains")||(l=l&&e.length==i.length)),y>1){var m=(e=e.map((function(e){return t.inspect(e)}))).pop();g&&(n=e.join(", ")+", and "+m),b&&(n=e.join(", ")+", or "+m);}else n=t.inspect(e[0]);n=(y>1?"keys ":"key ")+n,n=(r(this,"contains")?"contain ":"have ")+n,this.assert(l,"expected #{this} to "+p+n,"expected #{this} to not "+p+n,w.slice(0).sort(t.compareByInspect),i.sort(t.compareByInspect),!0);}function P(e,o,i){i&&r(this,"message",i);var s,a=r(this,"object"),c=r(this,"ssfi"),u=r(this,"message"),f=r(this,"negate")||!1;new n(a,u,c,!0).is.a("function"),(e instanceof RegExp||"string"==typeof e)&&(o=e,e=null);try{a();}catch(e){s=e;}var p=void 0===e&&void 0===o,l=Boolean(e&&o),h=!1,d=!1;if(p||!p&&!f){var y="an error";e instanceof Error?y="#{exp}":e&&(y=t.checkError.getConstructorName(e)),this.assert(s,"expected #{this} to throw "+y,"expected #{this} to not throw an error but #{act} was thrown",e&&e.toString(),s instanceof Error?s.toString():"string"==typeof s?s:s&&t.checkError.getConstructorName(s));}if(e&&s&&(e instanceof Error&&t.checkError.compatibleInstance(s,e)===f&&(l&&f?h=!0:this.assert(f,"expected #{this} to throw #{exp} but #{act} was thrown","expected #{this} to not throw #{exp}"+(s&&!f?" but #{act} was thrown":""),e.toString(),s.toString())),t.checkError.compatibleConstructor(s,e)===f&&(l&&f?h=!0:this.assert(f,"expected #{this} to throw #{exp} but #{act} was thrown","expected #{this} to not throw #{exp}"+(s?" but #{act} was thrown":""),e instanceof Error?e.toString():e&&t.checkError.getConstructorName(e),s instanceof Error?s.toString():s&&t.checkError.getConstructorName(s)))),s&&null!=o){var b="including";o instanceof RegExp&&(b="matching"),t.checkError.compatibleMessage(s,o)===f&&(l&&f?d=!0:this.assert(f,"expected #{this} to throw error "+b+" #{exp} but got #{act}","expected #{this} to throw error not "+b+" #{exp}",o,t.checkError.getMessage(s)));}h&&d&&this.assert(f,"expected #{this} to throw #{exp} but #{act} was thrown","expected #{this} to not throw #{exp}"+(s?" but #{act} was thrown":""),e instanceof Error?e.toString():e&&t.checkError.getConstructorName(e),s instanceof Error?s.toString():s&&t.checkError.getConstructorName(s)),r(this,"object",s);}function N(e,n){n&&r(this,"message",n);var o=r(this,"object"),i=r(this,"itself"),s="function"!=typeof o||i?o[e]:o.prototype[e];this.assert("function"==typeof s,"expected #{this} to respond to "+t.inspect(e),"expected #{this} to not respond to "+t.inspect(e));}function E(e,n){n&&r(this,"message",n);var o=e(r(this,"object"));this.assert(o,"expected #{this} to satisfy "+t.objDisplay(e),"expected #{this} to not satisfy"+t.objDisplay(e),!r(this,"negate"),o);}function S(e,t,i){i&&r(this,"message",i);var s=r(this,"object"),a=r(this,"message"),c=r(this,"ssfi");if(new n(s,a,c,!0).is.a("number"),"number"!=typeof e||"number"!=typeof t)throw new o((a=a?a+": ":"")+"the arguments to closeTo or approximately must be numbers"+(void 0===t?", and a delta is required":""),void 0,c);this.assert(Math.abs(s-e)<=t,"expected #{this} to be close to "+e+" +/- "+t,"expected #{this} not to be close to "+e+" +/- "+t);}function k(e,t,n,o,r){if(!o){if(e.length!==t.length)return !1;t=t.slice();}return e.every((function(e,i){if(r)return n?n(e,t[i]):e===t[i];if(!n){var s=t.indexOf(e);return -1!==s&&(o||t.splice(s,1),!0)}return t.some((function(r,i){return !!n(e,r)&&(o||t.splice(i,1),!0)}))}))}function A(e,o){o&&r(this,"message",o);var i=r(this,"object"),s=r(this,"message"),a=r(this,"ssfi"),c=r(this,"contains"),u=r(this,"deep");new n(e,s,a,!0).to.be.an("array"),c?this.assert(e.some((function(e){return i.indexOf(e)>-1})),"expected #{this} to contain one of #{exp}","expected #{this} to not contain one of #{exp}",e,i):u?this.assert(e.some((function(e){return t.eql(i,e)})),"expected #{this} to deeply equal one of #{exp}","expected #{this} to deeply equal one of #{exp}",e,i):this.assert(e.indexOf(i)>-1,"expected #{this} to be one of #{exp}","expected #{this} to not be one of #{exp}",e,i);}function D(e,t,o){o&&r(this,"message",o);var i,s=r(this,"object"),a=r(this,"message"),c=r(this,"ssfi");new n(s,a,c,!0).is.a("function"),t?(new n(e,a,c,!0).to.have.property(t),i=e[t]):(new n(e,a,c,!0).is.a("function"),i=e()),s();var u=null==t?e():e[t],f=null==t?i:"."+t;r(this,"deltaMsgObj",f),r(this,"initialDeltaValue",i),r(this,"finalDeltaValue",u),r(this,"deltaBehavior","change"),r(this,"realDelta",u!==i),this.assert(i!==u,"expected "+f+" to change","expected "+f+" to not change");}function T(e,t,o){o&&r(this,"message",o);var i,s=r(this,"object"),a=r(this,"message"),c=r(this,"ssfi");new n(s,a,c,!0).is.a("function"),t?(new n(e,a,c,!0).to.have.property(t),i=e[t]):(new n(e,a,c,!0).is.a("function"),i=e()),new n(i,a,c,!0).is.a("number"),s();var u=null==t?e():e[t],f=null==t?i:"."+t;r(this,"deltaMsgObj",f),r(this,"initialDeltaValue",i),r(this,"finalDeltaValue",u),r(this,"deltaBehavior","increase"),r(this,"realDelta",u-i),this.assert(u-i>0,"expected "+f+" to increase","expected "+f+" to not increase");}function q(e,t,o){o&&r(this,"message",o);var i,s=r(this,"object"),a=r(this,"message"),c=r(this,"ssfi");new n(s,a,c,!0).is.a("function"),t?(new n(e,a,c,!0).to.have.property(t),i=e[t]):(new n(e,a,c,!0).is.a("function"),i=e()),new n(i,a,c,!0).is.a("number"),s();var u=null==t?e():e[t],f=null==t?i:"."+t;r(this,"deltaMsgObj",f),r(this,"initialDeltaValue",i),r(this,"finalDeltaValue",u),r(this,"deltaBehavior","decrease"),r(this,"realDelta",i-u),this.assert(u-i<0,"expected "+f+" to decrease","expected "+f+" to not decrease");}function C(e,t){t&&r(this,"message",t);var n,o=r(this,"deltaMsgObj"),i=r(this,"initialDeltaValue"),s=r(this,"finalDeltaValue"),a=r(this,"deltaBehavior"),c=r(this,"realDelta");n="change"===a?Math.abs(s-i)===Math.abs(e):c===Math.abs(e),this.assert(n,"expected "+o+" to "+a+" by "+e,"expected "+o+" to not "+a+" by "+e);}["to","be","been","is","and","has","have","with","that","which","at","of","same","but","does","still","also"].forEach((function(e){n.addProperty(e);})),n.addProperty("not",(function(){r(this,"negate",!0);})),n.addProperty("deep",(function(){r(this,"deep",!0);})),n.addProperty("nested",(function(){r(this,"nested",!0);})),n.addProperty("own",(function(){r(this,"own",!0);})),n.addProperty("ordered",(function(){r(this,"ordered",!0);})),n.addProperty("any",(function(){r(this,"any",!0),r(this,"all",!1);})),n.addProperty("all",(function(){r(this,"all",!0),r(this,"any",!1);})),n.addChainableMethod("an",i),n.addChainableMethod("a",i),n.addChainableMethod("include",c,a),n.addChainableMethod("contain",c,a),n.addChainableMethod("contains",c,a),n.addChainableMethod("includes",c,a),n.addProperty("ok",(function(){this.assert(r(this,"object"),"expected #{this} to be truthy","expected #{this} to be falsy");})),n.addProperty("true",(function(){this.assert(!0===r(this,"object"),"expected #{this} to be true","expected #{this} to be false",!r(this,"negate"));})),n.addProperty("false",(function(){this.assert(!1===r(this,"object"),"expected #{this} to be false","expected #{this} to be true",!!r(this,"negate"));})),n.addProperty("null",(function(){this.assert(null===r(this,"object"),"expected #{this} to be null","expected #{this} not to be null");})),n.addProperty("undefined",(function(){this.assert(void 0===r(this,"object"),"expected #{this} to be undefined","expected #{this} not to be undefined");})),n.addProperty("NaN",(function(){this.assert(t.isNaN(r(this,"object")),"expected #{this} to be NaN","expected #{this} not to be NaN");})),n.addProperty("exist",u),n.addProperty("exists",u),n.addProperty("empty",(function(){var e,n=r(this,"object"),i=r(this,"ssfi"),s=r(this,"message");switch(s=s?s+": ":"",t.type(n).toLowerCase()){case"array":case"string":e=n.length;break;case"map":case"set":e=n.size;break;case"weakmap":case"weakset":throw new o(s+".empty was passed a weak collection",void 0,i);case"function":var a=s+".empty was passed a function "+t.getName(n);throw new o(a.trim(),void 0,i);default:if(n!==Object(n))throw new o(s+".empty was passed non-string primitive "+t.inspect(n),void 0,i);e=Object.keys(n).length;}this.assert(0===e,"expected #{this} to be empty","expected #{this} not to be empty");})),n.addProperty("arguments",f),n.addProperty("Arguments",f),n.addMethod("equal",p),n.addMethod("equals",p),n.addMethod("eq",p),n.addMethod("eql",l),n.addMethod("eqls",l),n.addMethod("above",h),n.addMethod("gt",h),n.addMethod("greaterThan",h),n.addMethod("least",d),n.addMethod("gte",d),n.addMethod("greaterThanOrEqual",d),n.addMethod("below",y),n.addMethod("lt",y),n.addMethod("lessThan",y),n.addMethod("most",b),n.addMethod("lte",b),n.addMethod("lessThanOrEqual",b),n.addMethod("within",(function(e,i,s){s&&r(this,"message",s);var a,c=r(this,"object"),u=r(this,"doLength"),f=r(this,"message"),p=f?f+": ":"",l=r(this,"ssfi"),h=t.type(c).toLowerCase(),d=t.type(e).toLowerCase(),y=t.type(i).toLowerCase(),b=!0,g="date"===d&&"date"===y?e.toUTCString()+".."+i.toUTCString():e+".."+i;if(u&&"map"!==h&&"set"!==h&&new n(c,f,l,!0).to.have.property("length"),u||"date"!==h||"date"===d&&"date"===y?"number"===d&&"number"===y||!u&&"number"!==h?u||"date"===h||"number"===h?b=!1:a=p+"expected "+("string"===h?"'"+c+"'":c)+" to be a number or a date":a=p+"the arguments to within must be numbers":a=p+"the arguments to within must be dates",b)throw new o(a,void 0,l);if(u){var w,m="length";"map"===h||"set"===h?(m="size",w=c.size):w=c.length,this.assert(w>=e&&w<=i,"expected #{this} to have a "+m+" within "+g,"expected #{this} to not have a "+m+" within "+g);}else this.assert(c>=e&&c<=i,"expected #{this} to be within "+g,"expected #{this} to not be within "+g);})),n.addMethod("instanceof",g),n.addMethod("instanceOf",g),n.addMethod("property",w),n.addMethod("ownProperty",m),n.addMethod("haveOwnProperty",m),n.addMethod("ownPropertyDescriptor",v),n.addMethod("haveOwnPropertyDescriptor",v),n.addChainableMethod("length",O,x),n.addChainableMethod("lengthOf",O,x),n.addMethod("match",j),n.addMethod("matches",j),n.addMethod("string",(function(e,o){o&&r(this,"message",o);var i=r(this,"object"),s=r(this,"message"),a=r(this,"ssfi");new n(i,s,a,!0).is.a("string"),this.assert(~i.indexOf(e),"expected #{this} to contain "+t.inspect(e),"expected #{this} to not contain "+t.inspect(e));})),n.addMethod("keys",M),n.addMethod("key",M),n.addMethod("throw",P),n.addMethod("throws",P),n.addMethod("Throw",P),n.addMethod("respondTo",N),n.addMethod("respondsTo",N),n.addProperty("itself",(function(){r(this,"itself",!0);})),n.addMethod("satisfy",E),n.addMethod("satisfies",E),n.addMethod("closeTo",S),n.addMethod("approximately",S),n.addMethod("members",(function(e,o){o&&r(this,"message",o);var i=r(this,"object"),s=r(this,"message"),a=r(this,"ssfi");new n(i,s,a,!0).to.be.an("array"),new n(e,s,a,!0).to.be.an("array");var c,u,f,p=r(this,"contains"),l=r(this,"ordered");p?(u="expected #{this} to be "+(c=l?"an ordered superset":"a superset")+" of #{exp}",f="expected #{this} to not be "+c+" of #{exp}"):(u="expected #{this} to have the same "+(c=l?"ordered members":"members")+" as #{exp}",f="expected #{this} to not have the same "+c+" as #{exp}");var h=r(this,"deep")?t.eql:void 0;this.assert(k(e,i,h,p,l),u,f,e,i,!0);})),n.addMethod("oneOf",A),n.addMethod("change",D),n.addMethod("changes",D),n.addMethod("increase",T),n.addMethod("increases",T),n.addMethod("decrease",q),n.addMethod("decreases",q),n.addMethod("by",C),n.addProperty("extensible",(function(){var e=r(this,"object"),t=e===Object(e)&&Object.isExtensible(e);this.assert(t,"expected #{this} to be extensible","expected #{this} to not be extensible");})),n.addProperty("sealed",(function(){var e=r(this,"object"),t=e!==Object(e)||Object.isSealed(e);this.assert(t,"expected #{this} to be sealed","expected #{this} to not be sealed");})),n.addProperty("frozen",(function(){var e=r(this,"object"),t=e!==Object(e)||Object.isFrozen(e);this.assert(t,"expected #{this} to be frozen","expected #{this} to not be frozen");})),n.addProperty("finite",(function(e){var t=r(this,"object");this.assert("number"==typeof t&&isFinite(t),"expected #{this} to be a finite number","expected #{this} to not be a finite number");}));};},{}],6:[function(e,t,n){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
t.exports=function(e,t){
/*!
   * Chai dependencies.
   */
var n=e.Assertion,o=t.flag,r=e.assert=function(t,o){new n(null,null,e.assert,!0).assert(t,o,"[ negation message unavailable ]");};
/*!
   * Module export.
   */r.fail=function(t,n,o,i){throw arguments.length<2&&(o=t,t=void 0),o=o||"assert.fail()",new e.AssertionError(o,{actual:t,expected:n,operator:i},r.fail)},r.isOk=function(e,t){new n(e,t,r.isOk,!0).is.ok;},r.isNotOk=function(e,t){new n(e,t,r.isNotOk,!0).is.not.ok;},r.equal=function(e,t,i){var s=new n(e,i,r.equal,!0);s.assert(t==o(s,"object"),"expected #{this} to equal #{exp}","expected #{this} to not equal #{act}",t,e,!0);},r.notEqual=function(e,t,i){var s=new n(e,i,r.notEqual,!0);s.assert(t!=o(s,"object"),"expected #{this} to not equal #{exp}","expected #{this} to equal #{act}",t,e,!0);},r.strictEqual=function(e,t,o){new n(e,o,r.strictEqual,!0).to.equal(t);},r.notStrictEqual=function(e,t,o){new n(e,o,r.notStrictEqual,!0).to.not.equal(t);},r.deepEqual=r.deepStrictEqual=function(e,t,o){new n(e,o,r.deepEqual,!0).to.eql(t);},r.notDeepEqual=function(e,t,o){new n(e,o,r.notDeepEqual,!0).to.not.eql(t);},r.isAbove=function(e,t,o){new n(e,o,r.isAbove,!0).to.be.above(t);},r.isAtLeast=function(e,t,o){new n(e,o,r.isAtLeast,!0).to.be.least(t);},r.isBelow=function(e,t,o){new n(e,o,r.isBelow,!0).to.be.below(t);},r.isAtMost=function(e,t,o){new n(e,o,r.isAtMost,!0).to.be.most(t);},r.isTrue=function(e,t){new n(e,t,r.isTrue,!0).is.true;},r.isNotTrue=function(e,t){new n(e,t,r.isNotTrue,!0).to.not.equal(!0);},r.isFalse=function(e,t){new n(e,t,r.isFalse,!0).is.false;},r.isNotFalse=function(e,t){new n(e,t,r.isNotFalse,!0).to.not.equal(!1);},r.isNull=function(e,t){new n(e,t,r.isNull,!0).to.equal(null);},r.isNotNull=function(e,t){new n(e,t,r.isNotNull,!0).to.not.equal(null);},r.isNaN=function(e,t){new n(e,t,r.isNaN,!0).to.be.NaN;},r.isNotNaN=function(e,t){new n(e,t,r.isNotNaN,!0).not.to.be.NaN;},r.exists=function(e,t){new n(e,t,r.exists,!0).to.exist;},r.notExists=function(e,t){new n(e,t,r.notExists,!0).to.not.exist;},r.isUndefined=function(e,t){new n(e,t,r.isUndefined,!0).to.equal(void 0);},r.isDefined=function(e,t){new n(e,t,r.isDefined,!0).to.not.equal(void 0);},r.isFunction=function(e,t){new n(e,t,r.isFunction,!0).to.be.a("function");},r.isNotFunction=function(e,t){new n(e,t,r.isNotFunction,!0).to.not.be.a("function");},r.isObject=function(e,t){new n(e,t,r.isObject,!0).to.be.a("object");},r.isNotObject=function(e,t){new n(e,t,r.isNotObject,!0).to.not.be.a("object");},r.isArray=function(e,t){new n(e,t,r.isArray,!0).to.be.an("array");},r.isNotArray=function(e,t){new n(e,t,r.isNotArray,!0).to.not.be.an("array");},r.isString=function(e,t){new n(e,t,r.isString,!0).to.be.a("string");},r.isNotString=function(e,t){new n(e,t,r.isNotString,!0).to.not.be.a("string");},r.isNumber=function(e,t){new n(e,t,r.isNumber,!0).to.be.a("number");},r.isNotNumber=function(e,t){new n(e,t,r.isNotNumber,!0).to.not.be.a("number");},r.isFinite=function(e,t){new n(e,t,r.isFinite,!0).to.be.finite;},r.isBoolean=function(e,t){new n(e,t,r.isBoolean,!0).to.be.a("boolean");},r.isNotBoolean=function(e,t){new n(e,t,r.isNotBoolean,!0).to.not.be.a("boolean");},r.typeOf=function(e,t,o){new n(e,o,r.typeOf,!0).to.be.a(t);},r.notTypeOf=function(e,t,o){new n(e,o,r.notTypeOf,!0).to.not.be.a(t);},r.instanceOf=function(e,t,o){new n(e,o,r.instanceOf,!0).to.be.instanceOf(t);},r.notInstanceOf=function(e,t,o){new n(e,o,r.notInstanceOf,!0).to.not.be.instanceOf(t);},r.include=function(e,t,o){new n(e,o,r.include,!0).include(t);},r.notInclude=function(e,t,o){new n(e,o,r.notInclude,!0).not.include(t);},r.deepInclude=function(e,t,o){new n(e,o,r.deepInclude,!0).deep.include(t);},r.notDeepInclude=function(e,t,o){new n(e,o,r.notDeepInclude,!0).not.deep.include(t);},r.nestedInclude=function(e,t,o){new n(e,o,r.nestedInclude,!0).nested.include(t);},r.notNestedInclude=function(e,t,o){new n(e,o,r.notNestedInclude,!0).not.nested.include(t);},r.deepNestedInclude=function(e,t,o){new n(e,o,r.deepNestedInclude,!0).deep.nested.include(t);},r.notDeepNestedInclude=function(e,t,o){new n(e,o,r.notDeepNestedInclude,!0).not.deep.nested.include(t);},r.ownInclude=function(e,t,o){new n(e,o,r.ownInclude,!0).own.include(t);},r.notOwnInclude=function(e,t,o){new n(e,o,r.notOwnInclude,!0).not.own.include(t);},r.deepOwnInclude=function(e,t,o){new n(e,o,r.deepOwnInclude,!0).deep.own.include(t);},r.notDeepOwnInclude=function(e,t,o){new n(e,o,r.notDeepOwnInclude,!0).not.deep.own.include(t);},r.match=function(e,t,o){new n(e,o,r.match,!0).to.match(t);},r.notMatch=function(e,t,o){new n(e,o,r.notMatch,!0).to.not.match(t);},r.property=function(e,t,o){new n(e,o,r.property,!0).to.have.property(t);},r.notProperty=function(e,t,o){new n(e,o,r.notProperty,!0).to.not.have.property(t);},r.propertyVal=function(e,t,o,i){new n(e,i,r.propertyVal,!0).to.have.property(t,o);},r.notPropertyVal=function(e,t,o,i){new n(e,i,r.notPropertyVal,!0).to.not.have.property(t,o);},r.deepPropertyVal=function(e,t,o,i){new n(e,i,r.deepPropertyVal,!0).to.have.deep.property(t,o);},r.notDeepPropertyVal=function(e,t,o,i){new n(e,i,r.notDeepPropertyVal,!0).to.not.have.deep.property(t,o);},r.ownProperty=function(e,t,o){new n(e,o,r.ownProperty,!0).to.have.own.property(t);},r.notOwnProperty=function(e,t,o){new n(e,o,r.notOwnProperty,!0).to.not.have.own.property(t);},r.ownPropertyVal=function(e,t,o,i){new n(e,i,r.ownPropertyVal,!0).to.have.own.property(t,o);},r.notOwnPropertyVal=function(e,t,o,i){new n(e,i,r.notOwnPropertyVal,!0).to.not.have.own.property(t,o);},r.deepOwnPropertyVal=function(e,t,o,i){new n(e,i,r.deepOwnPropertyVal,!0).to.have.deep.own.property(t,o);},r.notDeepOwnPropertyVal=function(e,t,o,i){new n(e,i,r.notDeepOwnPropertyVal,!0).to.not.have.deep.own.property(t,o);},r.nestedProperty=function(e,t,o){new n(e,o,r.nestedProperty,!0).to.have.nested.property(t);},r.notNestedProperty=function(e,t,o){new n(e,o,r.notNestedProperty,!0).to.not.have.nested.property(t);},r.nestedPropertyVal=function(e,t,o,i){new n(e,i,r.nestedPropertyVal,!0).to.have.nested.property(t,o);},r.notNestedPropertyVal=function(e,t,o,i){new n(e,i,r.notNestedPropertyVal,!0).to.not.have.nested.property(t,o);},r.deepNestedPropertyVal=function(e,t,o,i){new n(e,i,r.deepNestedPropertyVal,!0).to.have.deep.nested.property(t,o);},r.notDeepNestedPropertyVal=function(e,t,o,i){new n(e,i,r.notDeepNestedPropertyVal,!0).to.not.have.deep.nested.property(t,o);},r.lengthOf=function(e,t,o){new n(e,o,r.lengthOf,!0).to.have.lengthOf(t);},r.hasAnyKeys=function(e,t,o){new n(e,o,r.hasAnyKeys,!0).to.have.any.keys(t);},r.hasAllKeys=function(e,t,o){new n(e,o,r.hasAllKeys,!0).to.have.all.keys(t);},r.containsAllKeys=function(e,t,o){new n(e,o,r.containsAllKeys,!0).to.contain.all.keys(t);},r.doesNotHaveAnyKeys=function(e,t,o){new n(e,o,r.doesNotHaveAnyKeys,!0).to.not.have.any.keys(t);},r.doesNotHaveAllKeys=function(e,t,o){new n(e,o,r.doesNotHaveAllKeys,!0).to.not.have.all.keys(t);},r.hasAnyDeepKeys=function(e,t,o){new n(e,o,r.hasAnyDeepKeys,!0).to.have.any.deep.keys(t);},r.hasAllDeepKeys=function(e,t,o){new n(e,o,r.hasAllDeepKeys,!0).to.have.all.deep.keys(t);},r.containsAllDeepKeys=function(e,t,o){new n(e,o,r.containsAllDeepKeys,!0).to.contain.all.deep.keys(t);},r.doesNotHaveAnyDeepKeys=function(e,t,o){new n(e,o,r.doesNotHaveAnyDeepKeys,!0).to.not.have.any.deep.keys(t);},r.doesNotHaveAllDeepKeys=function(e,t,o){new n(e,o,r.doesNotHaveAllDeepKeys,!0).to.not.have.all.deep.keys(t);},r.throws=function(e,t,i,s){("string"==typeof t||t instanceof RegExp)&&(i=t,t=null);var a=new n(e,s,r.throws,!0).to.throw(t,i);return o(a,"object")},r.doesNotThrow=function(e,t,o,i){("string"==typeof t||t instanceof RegExp)&&(o=t,t=null),new n(e,i,r.doesNotThrow,!0).to.not.throw(t,o);},r.operator=function(i,s,a,c){var u;switch(s){case"==":u=i==a;break;case"===":u=i===a;break;case">":u=i>a;break;case">=":u=i>=a;break;case"<":u=i<a;break;case"<=":u=i<=a;break;case"!=":u=i!=a;break;case"!==":u=i!==a;break;default:throw c=c?c+": ":c,new e.AssertionError(c+'Invalid operator "'+s+'"',void 0,r.operator)}var f=new n(u,c,r.operator,!0);f.assert(!0===o(f,"object"),"expected "+t.inspect(i)+" to be "+s+" "+t.inspect(a),"expected "+t.inspect(i)+" to not be "+s+" "+t.inspect(a));},r.closeTo=function(e,t,o,i){new n(e,i,r.closeTo,!0).to.be.closeTo(t,o);},r.approximately=function(e,t,o,i){new n(e,i,r.approximately,!0).to.be.approximately(t,o);},r.sameMembers=function(e,t,o){new n(e,o,r.sameMembers,!0).to.have.same.members(t);},r.notSameMembers=function(e,t,o){new n(e,o,r.notSameMembers,!0).to.not.have.same.members(t);},r.sameDeepMembers=function(e,t,o){new n(e,o,r.sameDeepMembers,!0).to.have.same.deep.members(t);},r.notSameDeepMembers=function(e,t,o){new n(e,o,r.notSameDeepMembers,!0).to.not.have.same.deep.members(t);},r.sameOrderedMembers=function(e,t,o){new n(e,o,r.sameOrderedMembers,!0).to.have.same.ordered.members(t);},r.notSameOrderedMembers=function(e,t,o){new n(e,o,r.notSameOrderedMembers,!0).to.not.have.same.ordered.members(t);},r.sameDeepOrderedMembers=function(e,t,o){new n(e,o,r.sameDeepOrderedMembers,!0).to.have.same.deep.ordered.members(t);},r.notSameDeepOrderedMembers=function(e,t,o){new n(e,o,r.notSameDeepOrderedMembers,!0).to.not.have.same.deep.ordered.members(t);},r.includeMembers=function(e,t,o){new n(e,o,r.includeMembers,!0).to.include.members(t);},r.notIncludeMembers=function(e,t,o){new n(e,o,r.notIncludeMembers,!0).to.not.include.members(t);},r.includeDeepMembers=function(e,t,o){new n(e,o,r.includeDeepMembers,!0).to.include.deep.members(t);},r.notIncludeDeepMembers=function(e,t,o){new n(e,o,r.notIncludeDeepMembers,!0).to.not.include.deep.members(t);},r.includeOrderedMembers=function(e,t,o){new n(e,o,r.includeOrderedMembers,!0).to.include.ordered.members(t);},r.notIncludeOrderedMembers=function(e,t,o){new n(e,o,r.notIncludeOrderedMembers,!0).to.not.include.ordered.members(t);},r.includeDeepOrderedMembers=function(e,t,o){new n(e,o,r.includeDeepOrderedMembers,!0).to.include.deep.ordered.members(t);},r.notIncludeDeepOrderedMembers=function(e,t,o){new n(e,o,r.notIncludeDeepOrderedMembers,!0).to.not.include.deep.ordered.members(t);},r.oneOf=function(e,t,o){new n(e,o,r.oneOf,!0).to.be.oneOf(t);},r.changes=function(e,t,o,i){3===arguments.length&&"function"==typeof t&&(i=o,o=null),new n(e,i,r.changes,!0).to.change(t,o);},r.changesBy=function(e,t,o,i,s){if(4===arguments.length&&"function"==typeof t){var a=i;i=o,s=a;}else 3===arguments.length&&(i=o,o=null);new n(e,s,r.changesBy,!0).to.change(t,o).by(i);},r.doesNotChange=function(e,t,o,i){return 3===arguments.length&&"function"==typeof t&&(i=o,o=null),new n(e,i,r.doesNotChange,!0).to.not.change(t,o)},r.changesButNotBy=function(e,t,o,i,s){if(4===arguments.length&&"function"==typeof t){var a=i;i=o,s=a;}else 3===arguments.length&&(i=o,o=null);new n(e,s,r.changesButNotBy,!0).to.change(t,o).but.not.by(i);},r.increases=function(e,t,o,i){return 3===arguments.length&&"function"==typeof t&&(i=o,o=null),new n(e,i,r.increases,!0).to.increase(t,o)},r.increasesBy=function(e,t,o,i,s){if(4===arguments.length&&"function"==typeof t){var a=i;i=o,s=a;}else 3===arguments.length&&(i=o,o=null);new n(e,s,r.increasesBy,!0).to.increase(t,o).by(i);},r.doesNotIncrease=function(e,t,o,i){return 3===arguments.length&&"function"==typeof t&&(i=o,o=null),new n(e,i,r.doesNotIncrease,!0).to.not.increase(t,o)},r.increasesButNotBy=function(e,t,o,i,s){if(4===arguments.length&&"function"==typeof t){var a=i;i=o,s=a;}else 3===arguments.length&&(i=o,o=null);new n(e,s,r.increasesButNotBy,!0).to.increase(t,o).but.not.by(i);},r.decreases=function(e,t,o,i){return 3===arguments.length&&"function"==typeof t&&(i=o,o=null),new n(e,i,r.decreases,!0).to.decrease(t,o)},r.decreasesBy=function(e,t,o,i,s){if(4===arguments.length&&"function"==typeof t){var a=i;i=o,s=a;}else 3===arguments.length&&(i=o,o=null);new n(e,s,r.decreasesBy,!0).to.decrease(t,o).by(i);},r.doesNotDecrease=function(e,t,o,i){return 3===arguments.length&&"function"==typeof t&&(i=o,o=null),new n(e,i,r.doesNotDecrease,!0).to.not.decrease(t,o)},r.doesNotDecreaseBy=function(e,t,o,i,s){if(4===arguments.length&&"function"==typeof t){var a=i;i=o,s=a;}else 3===arguments.length&&(i=o,o=null);return new n(e,s,r.doesNotDecreaseBy,!0).to.not.decrease(t,o).by(i)},r.decreasesButNotBy=function(e,t,o,i,s){if(4===arguments.length&&"function"==typeof t){var a=i;i=o,s=a;}else 3===arguments.length&&(i=o,o=null);new n(e,s,r.decreasesButNotBy,!0).to.decrease(t,o).but.not.by(i);},
/*!
   * ### .ifError(object)
   *
   * Asserts if value is not a false value, and throws if it is a true value.
   * This is added to allow for chai to be a drop-in replacement for Node's
   * assert class.
   *
   *     var err = new Error('I am a custom error');
   *     assert.ifError(err); // Rethrows err!
   *
   * @name ifError
   * @param {Object} object
   * @namespace Assert
   * @api public
   */
r.ifError=function(e){if(e)throw e},r.isExtensible=function(e,t){new n(e,t,r.isExtensible,!0).to.be.extensible;},r.isNotExtensible=function(e,t){new n(e,t,r.isNotExtensible,!0).to.not.be.extensible;},r.isSealed=function(e,t){new n(e,t,r.isSealed,!0).to.be.sealed;},r.isNotSealed=function(e,t){new n(e,t,r.isNotSealed,!0).to.not.be.sealed;},r.isFrozen=function(e,t){new n(e,t,r.isFrozen,!0).to.be.frozen;},r.isNotFrozen=function(e,t){new n(e,t,r.isNotFrozen,!0).to.not.be.frozen;},r.isEmpty=function(e,t){new n(e,t,r.isEmpty,!0).to.be.empty;},r.isNotEmpty=function(e,t){new n(e,t,r.isNotEmpty,!0).to.not.be.empty;},
/*!
   * Aliases.
   */
function e(t,n){return r[n]=r[t],e}("isOk","ok")("isNotOk","notOk")("throws","throw")("throws","Throw")("isExtensible","extensible")("isNotExtensible","notExtensible")("isSealed","sealed")("isNotSealed","notSealed")("isFrozen","frozen")("isNotFrozen","notFrozen")("isEmpty","empty")("isNotEmpty","notEmpty");};},{}],7:[function(e,t,n){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
t.exports=function(e,t){e.expect=function(t,n){return new e.Assertion(t,n)},e.expect.fail=function(t,n,o,r){throw arguments.length<2&&(o=t,t=void 0),o=o||"expect.fail()",new e.AssertionError(o,{actual:t,expected:n,operator:r},e.expect.fail)};};},{}],8:[function(e,t,n){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
t.exports=function(e,t){var n=e.Assertion;function o(){function t(){return this instanceof String||this instanceof Number||this instanceof Boolean||"function"==typeof Symbol&&this instanceof Symbol||"function"==typeof BigInt&&this instanceof BigInt?new n(this.valueOf(),null,t):new n(this,null,t)}function o(e){Object.defineProperty(this,"should",{value:e,enumerable:!0,configurable:!0,writable:!0});}Object.defineProperty(Object.prototype,"should",{set:o,get:t,configurable:!0});var r={fail:function(t,n,o,i){throw arguments.length<2&&(o=t,t=void 0),o=o||"should.fail()",new e.AssertionError(o,{actual:t,expected:n,operator:i},r.fail)},equal:function(e,t,o){new n(e,o).to.equal(t);},Throw:function(e,t,o,r){new n(e,r).to.Throw(t,o);},exist:function(e,t){new n(e,t).to.exist;},not:{}};return r.not.equal=function(e,t,o){new n(e,o).to.not.equal(t);},r.not.Throw=function(e,t,o,r){new n(e,r).to.not.Throw(t,o);},r.not.exist=function(e,t){new n(e,t).to.not.exist;},r.throw=r.Throw,r.not.throw=r.not.Throw,r}e.should=o,e.Should=o;};},{}],9:[function(e,t,n){
/*!
 * Chai - addChainingMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Module dependencies
 */
var o=e("./addLengthGuard"),r=e("../../chai"),i=e("./flag"),s=e("./proxify"),a=e("./transferFlags"),c="function"==typeof Object.setPrototypeOf,u=function(){},f=Object.getOwnPropertyNames(u).filter((function(e){var t=Object.getOwnPropertyDescriptor(u,e);return "object"!=typeof t||!t.configurable})),p=Function.prototype.call,l=Function.prototype.apply;t.exports=function(e,t,n,u){"function"!=typeof u&&(u=function(){});var h={method:n,chainingBehavior:u};e.__methods||(e.__methods={}),e.__methods[t]=h,Object.defineProperty(e,t,{get:function(){h.chainingBehavior.call(this);var n=function(){i(this,"lockSsfi")||i(this,"ssfi",n);var e=h.method.apply(this,arguments);if(void 0!==e)return e;var t=new r.Assertion;return a(this,t),t};if(o(n,t,!0),c){var u=Object.create(this);u.call=p,u.apply=l,Object.setPrototypeOf(n,u);}else Object.getOwnPropertyNames(e).forEach((function(t){if(-1===f.indexOf(t)){var o=Object.getOwnPropertyDescriptor(e,t);Object.defineProperty(n,t,o);}}));return a(this,n),s(n)},configurable:!0});};},{"../../chai":2,"./addLengthGuard":10,"./flag":15,"./proxify":31,"./transferFlags":33}],10:[function(e,t,n){var o=Object.getOwnPropertyDescriptor((function(){}),"length");
/*!
 * Chai - addLengthGuard utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */t.exports=function(e,t,n){return o.configurable?(Object.defineProperty(e,"length",{get:function(){if(n)throw Error("Invalid Chai property: "+t+'.length. Due to a compatibility issue, "length" cannot directly follow "'+t+'". Use "'+t+'.lengthOf" instead.');throw Error("Invalid Chai property: "+t+'.length. See docs for proper usage of "'+t+'".')}}),e):e};},{}],11:[function(e,t,n){
/*!
 * Chai - addMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var o=e("./addLengthGuard"),r=e("../../chai"),i=e("./flag"),s=e("./proxify"),a=e("./transferFlags");t.exports=function(e,t,n){var c=function(){i(this,"lockSsfi")||i(this,"ssfi",c);var e=n.apply(this,arguments);if(void 0!==e)return e;var t=new r.Assertion;return a(this,t),t};o(c,t,!1),e[t]=s(c,t);};},{"../../chai":2,"./addLengthGuard":10,"./flag":15,"./proxify":31,"./transferFlags":33}],12:[function(e,t,n){
/*!
 * Chai - addProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var o=e("../../chai"),r=e("./flag"),i=e("./isProxyEnabled"),s=e("./transferFlags");t.exports=function(e,t,n){n=void 0===n?function(){}:n,Object.defineProperty(e,t,{get:function e(){i()||r(this,"lockSsfi")||r(this,"ssfi",e);var t=n.call(this);if(void 0!==t)return t;var a=new o.Assertion;return s(this,a),a},configurable:!0});};},{"../../chai":2,"./flag":15,"./isProxyEnabled":26,"./transferFlags":33}],13:[function(e,t,n){
/*!
 * Chai - compareByInspect utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Module dependencies
 */
var o=e("./inspect");t.exports=function(e,t){return o(e)<o(t)?-1:1};},{"./inspect":24}],14:[function(e,t,n){
/*!
 * Chai - expectTypes utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var o=e("assertion-error"),r=e("./flag"),i=e("type-detect");t.exports=function(e,t){var n=r(e,"message"),s=r(e,"ssfi");n=n?n+": ":"",e=r(e,"object"),(t=t.map((function(e){return e.toLowerCase()}))).sort();var a=t.map((function(e,n){var o=~["a","e","i","o","u"].indexOf(e.charAt(0))?"an":"a";return (t.length>1&&n===t.length-1?"or ":"")+o+" "+e})).join(", "),c=i(e).toLowerCase();if(!t.some((function(e){return c===e})))throw new o(n+"object tested must be "+a+", but "+c+" given",void 0,s)};},{"./flag":15,"assertion-error":34,"type-detect":39}],15:[function(e,t,n){
/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
t.exports=function(e,t,n){var o=e.__flags||(e.__flags=Object.create(null));if(3!==arguments.length)return o[t];o[t]=n;};},{}],16:[function(e,t,n){
/*!
 * Chai - getActual utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
t.exports=function(e,t){return t.length>4?t[4]:e._obj};},{}],17:[function(e,t,n){
/*!
 * Chai - getEnumerableProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
t.exports=function(e){var t=[];for(var n in e)t.push(n);return t};},{}],18:[function(e,t,n){
/*!
 * Chai - message composition utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Module dependencies
 */
var o=e("./flag"),r=e("./getActual"),i=e("./objDisplay");t.exports=function(e,t){var n=o(e,"negate"),s=o(e,"object"),a=t[3],c=r(e,t),u=n?t[2]:t[1],f=o(e,"message");return "function"==typeof u&&(u=u()),u=(u=u||"").replace(/#\{this\}/g,(function(){return i(s)})).replace(/#\{act\}/g,(function(){return i(c)})).replace(/#\{exp\}/g,(function(){return i(a)})),f?f+": "+u:u};},{"./flag":15,"./getActual":16,"./objDisplay":27}],19:[function(e,t,n){var o=e("type-detect"),r=e("./flag");function i(e){var t=o(e);return -1!==["Array","Object","function"].indexOf(t)}t.exports=function(e,t){var n=r(e,"operator"),o=r(e,"negate"),s=t[3],a=o?t[2]:t[1];if(n)return n;if("function"==typeof a&&(a=a()),(a=a||"")&&!/\shave\s/.test(a)){var c=i(s);return /\snot\s/.test(a)?c?"notDeepStrictEqual":"notStrictEqual":c?"deepStrictEqual":"strictEqual"}};},{"./flag":15,"type-detect":39}],20:[function(e,t,n){
/*!
 * Chai - getOwnEnumerableProperties utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Module dependencies
 */
var o=e("./getOwnEnumerablePropertySymbols");t.exports=function(e){return Object.keys(e).concat(o(e))};},{"./getOwnEnumerablePropertySymbols":21}],21:[function(e,t,n){
/*!
 * Chai - getOwnEnumerablePropertySymbols utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
t.exports=function(e){return "function"!=typeof Object.getOwnPropertySymbols?[]:Object.getOwnPropertySymbols(e).filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))};},{}],22:[function(e,t,n){
/*!
 * Chai - getProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
t.exports=function(e){var t=Object.getOwnPropertyNames(e);function n(e){-1===t.indexOf(e)&&t.push(e);}for(var o=Object.getPrototypeOf(e);null!==o;)Object.getOwnPropertyNames(o).forEach(n),o=Object.getPrototypeOf(o);return t};},{}],23:[function(e,t,n){
/*!
 * chai
 * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Dependencies that are used for multiple exports are required here only once
 */
var o=e("pathval");
/*!
 * test utility
 */n.test=e("./test"),
/*!
 * type utility
 */
n.type=e("type-detect"),
/*!
 * expectTypes utility
 */
n.expectTypes=e("./expectTypes"),
/*!
 * message utility
 */
n.getMessage=e("./getMessage"),
/*!
 * actual utility
 */
n.getActual=e("./getActual"),
/*!
 * Inspect util
 */
n.inspect=e("./inspect"),
/*!
 * Object Display util
 */
n.objDisplay=e("./objDisplay"),
/*!
 * Flag utility
 */
n.flag=e("./flag"),
/*!
 * Flag transferring utility
 */
n.transferFlags=e("./transferFlags"),
/*!
 * Deep equal utility
 */
n.eql=e("deep-eql"),
/*!
 * Deep path info
 */
n.getPathInfo=o.getPathInfo,
/*!
 * Check if a property exists
 */
n.hasProperty=o.hasProperty,
/*!
 * Function name
 */
n.getName=e("get-func-name"),
/*!
 * add Property
 */
n.addProperty=e("./addProperty"),
/*!
 * add Method
 */
n.addMethod=e("./addMethod"),
/*!
 * overwrite Property
 */
n.overwriteProperty=e("./overwriteProperty"),
/*!
 * overwrite Method
 */
n.overwriteMethod=e("./overwriteMethod"),
/*!
 * Add a chainable method
 */
n.addChainableMethod=e("./addChainableMethod"),
/*!
 * Overwrite chainable method
 */
n.overwriteChainableMethod=e("./overwriteChainableMethod"),
/*!
 * Compare by inspect method
 */
n.compareByInspect=e("./compareByInspect"),
/*!
 * Get own enumerable property symbols method
 */
n.getOwnEnumerablePropertySymbols=e("./getOwnEnumerablePropertySymbols"),
/*!
 * Get own enumerable properties method
 */
n.getOwnEnumerableProperties=e("./getOwnEnumerableProperties"),
/*!
 * Checks error against a given set of criteria
 */
n.checkError=e("check-error"),
/*!
 * Proxify util
 */
n.proxify=e("./proxify"),
/*!
 * addLengthGuard util
 */
n.addLengthGuard=e("./addLengthGuard"),
/*!
 * isProxyEnabled helper
 */
n.isProxyEnabled=e("./isProxyEnabled"),
/*!
 * isNaN method
 */
n.isNaN=e("./isNaN"),
/*!
 * getOperator method
 */
n.getOperator=e("./getOperator");},{"./addChainableMethod":9,"./addLengthGuard":10,"./addMethod":11,"./addProperty":12,"./compareByInspect":13,"./expectTypes":14,"./flag":15,"./getActual":16,"./getMessage":18,"./getOperator":19,"./getOwnEnumerableProperties":20,"./getOwnEnumerablePropertySymbols":21,"./inspect":24,"./isNaN":25,"./isProxyEnabled":26,"./objDisplay":27,"./overwriteChainableMethod":28,"./overwriteMethod":29,"./overwriteProperty":30,"./proxify":31,"./test":32,"./transferFlags":33,"check-error":35,"deep-eql":36,"get-func-name":37,pathval:38,"type-detect":39}],24:[function(e,t,n){var o=e("get-func-name"),r=e("./getProperties"),i=e("./getEnumerableProperties"),s=e("../config");function a(e,t,n,o){return u({showHidden:t,seen:[],stylize:function(e){return e}},e,void 0===n?2:n)}t.exports=a;var c=function(e){return "object"==typeof HTMLElement?e instanceof HTMLElement:e&&"object"==typeof e&&"nodeType"in e&&1===e.nodeType&&"string"==typeof e.nodeName};function u(e,t,s){if(t&&"function"==typeof t.inspect&&t.inspect!==n.inspect&&(!t.constructor||t.constructor.prototype!==t)){var a=t.inspect(s,e);return "string"!=typeof a&&(a=u(e,a,s)),a}var x=f(e,t);if(x)return x;if(c(t)){if("outerHTML"in t)return t.outerHTML;try{if(document.xmlVersion)return (new XMLSerializer).serializeToString(t);var O="http://www.w3.org/1999/xhtml",j=document.createElementNS(O,"_");j.appendChild(t.cloneNode(!1));var M=j.innerHTML.replace("><",">"+t.innerHTML+"<");return j.innerHTML="",M}catch(e){}}var P,N,E=i(t),S=e.showHidden?r(t):E;if(0===S.length||v(t)&&(1===S.length&&"stack"===S[0]||2===S.length&&"description"===S[0]&&"stack"===S[1])){if("function"==typeof t)return N=(P=o(t))?": "+P:"",e.stylize("[Function"+N+"]","special");if(w(t))return e.stylize(RegExp.prototype.toString.call(t),"regexp");if(m(t))return e.stylize(Date.prototype.toUTCString.call(t),"date");if(v(t))return p(t)}var k,A="",D=!1,T=!1,q=["{","}"];if(b(t)&&(T=!0,q=["[","]"]),g(t)&&(D=!0,q=["[","]"]),"function"==typeof t&&(A=" [Function"+(N=(P=o(t))?": "+P:"")+"]"),w(t)&&(A=" "+RegExp.prototype.toString.call(t)),m(t)&&(A=" "+Date.prototype.toUTCString.call(t)),v(t))return p(t);if(0===S.length&&(!D||0==t.length))return q[0]+A+q[1];if(s<0)return w(t)?e.stylize(RegExp.prototype.toString.call(t),"regexp"):e.stylize("[Object]","special");if(e.seen.push(t),D)k=l(e,t,s,E,S);else {if(T)return h(t);k=S.map((function(n){return d(e,t,s,E,n,D)}));}return e.seen.pop(),y(k,A,q)}function f(e,t){switch(typeof t){case"undefined":return e.stylize("undefined","undefined");case"string":var n="'"+JSON.stringify(t).replace(/^"|"$/g,"").replace(/'/g,"\\'").replace(/\\"/g,'"')+"'";return e.stylize(n,"string");case"number":return 0===t&&1/t==-1/0?e.stylize("-0","number"):e.stylize(""+t,"number");case"boolean":return e.stylize(""+t,"boolean");case"symbol":return e.stylize(t.toString(),"symbol");case"bigint":return e.stylize(t.toString()+"n","bigint")}if(null===t)return e.stylize("null","null")}function p(e){return "["+Error.prototype.toString.call(e)+"]"}function l(e,t,n,o,r){for(var i=[],s=0,a=t.length;s<a;++s)Object.prototype.hasOwnProperty.call(t,String(s))?i.push(d(e,t,n,o,String(s),!0)):i.push("");return r.forEach((function(r){r.match(/^\d+$/)||i.push(d(e,t,n,o,r,!0));})),i}function h(e){for(var t="[ ",n=0;n<e.length;++n){if(t.length>=s.truncateThreshold-7){t+="...";break}t+=e[n]+", ";}return -1!==(t+=" ]").indexOf(",  ]")&&(t=t.replace(",  ]"," ]")),t}function d(e,t,n,o,r,i){var s,a,c=Object.getOwnPropertyDescriptor(t,r);if(c&&(c.get?a=c.set?e.stylize("[Getter/Setter]","special"):e.stylize("[Getter]","special"):c.set&&(a=e.stylize("[Setter]","special"))),o.indexOf(r)<0&&(s="["+r+"]"),a||(e.seen.indexOf(t[r])<0?(a=u(e,t[r],null===n?null:n-1)).indexOf("\n")>-1&&(a=i?a.split("\n").map((function(e){return "  "+e})).join("\n").substr(2):"\n"+a.split("\n").map((function(e){return "   "+e})).join("\n")):a=e.stylize("[Circular]","special")),void 0===s){if(i&&r.match(/^\d+$/))return a;(s=JSON.stringify(""+r)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)?(s=s.substr(1,s.length-2),s=e.stylize(s,"name")):(s=s.replace(/'/g,"\\'").replace(/\\"/g,'"').replace(/(^"|"$)/g,"'"),s=e.stylize(s,"string"));}return s+": "+a}function y(e,t,n){return e.reduce((function(e,t){return e+t.length+1}),0)>60?n[0]+(""===t?"":t+"\n ")+" "+e.join(",\n  ")+" "+n[1]:n[0]+t+" "+e.join(", ")+" "+n[1]}function b(e){return "object"==typeof e&&/\w+Array]$/.test(x(e))}function g(e){return Array.isArray(e)||"object"==typeof e&&"[object Array]"===x(e)}function w(e){return "object"==typeof e&&"[object RegExp]"===x(e)}function m(e){return "object"==typeof e&&"[object Date]"===x(e)}function v(e){return "object"==typeof e&&"[object Error]"===x(e)}function x(e){return Object.prototype.toString.call(e)}},{"../config":4,"./getEnumerableProperties":17,"./getProperties":22,"get-func-name":37}],25:[function(e,t,n){
/*!
 * Chai - isNaN utility
 * Copyright(c) 2012-2015 Sakthipriyan Vairamani <thechargingvolcano@gmail.com>
 * MIT Licensed
 */
function o(e){return e!=e}t.exports=Number.isNaN||o;},{}],26:[function(e,t,n){var o=e("../config");
/*!
 * Chai - isProxyEnabled helper
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */t.exports=function(){return o.useProxy&&"undefined"!=typeof Proxy&&"undefined"!=typeof Reflect};},{"../config":4}],27:[function(e,t,n){
/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Module dependencies
 */
var o=e("./inspect"),r=e("../config");t.exports=function(e){var t=o(e),n=Object.prototype.toString.call(e);if(r.truncateThreshold&&t.length>=r.truncateThreshold){if("[object Function]"===n)return e.name&&""!==e.name?"[Function: "+e.name+"]":"[Function]";if("[object Array]"===n)return "[ Array("+e.length+") ]";if("[object Object]"===n){var i=Object.keys(e);return "{ Object ("+(i.length>2?i.splice(0,2).join(", ")+", ...":i.join(", "))+") }"}return t}return t};},{"../config":4,"./inspect":24}],28:[function(e,t,n){
/*!
 * Chai - overwriteChainableMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var o=e("../../chai"),r=e("./transferFlags");t.exports=function(e,t,n,i){var s=e.__methods[t],a=s.chainingBehavior;s.chainingBehavior=function(){var e=i(a).call(this);if(void 0!==e)return e;var t=new o.Assertion;return r(this,t),t};var c=s.method;s.method=function(){var e=n(c).apply(this,arguments);if(void 0!==e)return e;var t=new o.Assertion;return r(this,t),t};};},{"../../chai":2,"./transferFlags":33}],29:[function(e,t,n){
/*!
 * Chai - overwriteMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var o=e("./addLengthGuard"),r=e("../../chai"),i=e("./flag"),s=e("./proxify"),a=e("./transferFlags");t.exports=function(e,t,n){var c=e[t],u=function(){throw new Error(t+" is not a function")};c&&"function"==typeof c&&(u=c);var f=function(){i(this,"lockSsfi")||i(this,"ssfi",f);var e=i(this,"lockSsfi");i(this,"lockSsfi",!0);var t=n(u).apply(this,arguments);if(i(this,"lockSsfi",e),void 0!==t)return t;var o=new r.Assertion;return a(this,o),o};o(f,t,!1),e[t]=s(f,t);};},{"../../chai":2,"./addLengthGuard":10,"./flag":15,"./proxify":31,"./transferFlags":33}],30:[function(e,t,n){
/*!
 * Chai - overwriteProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var o=e("../../chai"),r=e("./flag"),i=e("./isProxyEnabled"),s=e("./transferFlags");t.exports=function(e,t,n){var a=Object.getOwnPropertyDescriptor(e,t),c=function(){};a&&"function"==typeof a.get&&(c=a.get),Object.defineProperty(e,t,{get:function e(){i()||r(this,"lockSsfi")||r(this,"ssfi",e);var t=r(this,"lockSsfi");r(this,"lockSsfi",!0);var a=n(c).call(this);if(r(this,"lockSsfi",t),void 0!==a)return a;var u=new o.Assertion;return s(this,u),u},configurable:!0});};},{"../../chai":2,"./flag":15,"./isProxyEnabled":26,"./transferFlags":33}],31:[function(e,t,n){var o=e("../config"),r=e("./flag"),i=e("./getProperties"),s=e("./isProxyEnabled"),a=["__flags","__methods","_obj","assert"];function c(e,t,n){if(Math.abs(e.length-t.length)>=n)return n;for(var o=[],r=0;r<=e.length;r++)o[r]=Array(t.length+1).fill(0),o[r][0]=r;for(var i=0;i<t.length;i++)o[0][i]=i;for(r=1;r<=e.length;r++){var s=e.charCodeAt(r-1);for(i=1;i<=t.length;i++)Math.abs(r-i)>=n?o[r][i]=n:o[r][i]=Math.min(o[r-1][i]+1,o[r][i-1]+1,o[r-1][i-1]+(s===t.charCodeAt(i-1)?0:1));}return o[e.length][t.length]}t.exports=function(e,t){return s()?new Proxy(e,{get:function e(n,s){if("string"==typeof s&&-1===o.proxyExcludedKeys.indexOf(s)&&!Reflect.has(n,s)){if(t)throw Error("Invalid Chai property: "+t+"."+s+'. See docs for proper usage of "'+t+'".');var u=null,f=4;throw i(n).forEach((function(e){if(!Object.prototype.hasOwnProperty(e)&&-1===a.indexOf(e)){var t=c(s,e,f);t<f&&(u=e,f=t);}})),null!==u?Error("Invalid Chai property: "+s+'. Did you mean "'+u+'"?'):Error("Invalid Chai property: "+s)}return -1!==a.indexOf(s)||r(n,"lockSsfi")||r(n,"ssfi",e),Reflect.get(n,s)}}):e};},{"../config":4,"./flag":15,"./getProperties":22,"./isProxyEnabled":26}],32:[function(e,t,n){
/*!
 * Chai - test utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Module dependencies
 */
var o=e("./flag");t.exports=function(e,t){var n=o(e,"negate"),r=t[0];return n?!r:r};},{"./flag":15}],33:[function(e,t,n){
/*!
 * Chai - transferFlags utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
t.exports=function(e,t,n){var o=e.__flags||(e.__flags=Object.create(null));for(var r in t.__flags||(t.__flags=Object.create(null)),n=3!==arguments.length||n,o)(n||"object"!==r&&"ssfi"!==r&&"lockSsfi"!==r&&"message"!=r)&&(t.__flags[r]=o[r]);};},{}],34:[function(e,t,n){
/*!
 * assertion-error
 * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>
 * MIT Licensed
 */
/*!
 * Return a function that will copy properties from
 * one object to another excluding any originally
 * listed. Returned function will create a new `{}`.
 *
 * @param {String} excluded properties ...
 * @return {Function}
 */
function o(){var e=[].slice.call(arguments);function t(t,n){Object.keys(n).forEach((function(o){~e.indexOf(o)||(t[o]=n[o]);}));}return function(){for(var e=[].slice.call(arguments),n=0,o={};n<e.length;n++)t(o,e[n]);return o}}
/*!
 * Primary Exports
 */function r(e,t,n){var i=o("name","message","stack","constructor","toJSON")(t||{});for(var s in this.message=e||"Unspecified AssertionError",this.showDiff=!1,i)this[s]=i[s];if(n=n||r,Error.captureStackTrace)Error.captureStackTrace(this,n);else try{throw new Error}catch(e){this.stack=e.stack;}}
/*!
 * Inherit from Error.prototype
 */t.exports=r,r.prototype=Object.create(Error.prototype),
/*!
 * Statically set name
 */
r.prototype.name="AssertionError",
/*!
 * Ensure correct constructor
 */
r.prototype.constructor=r,r.prototype.toJSON=function(e){var t=o("constructor","toJSON","stack")({name:this.name},this);return !1!==e&&this.stack&&(t.stack=this.stack),t};},{}],35:[function(e,t,n){function o(e,t){return t instanceof Error&&e===t}function r(e,t){return t instanceof Error?e.constructor===t.constructor||e instanceof t.constructor:(t.prototype instanceof Error||t===Error)&&(e.constructor===t||e instanceof t)}function i(e,t){var n="string"==typeof e?e:e.message;return t instanceof RegExp?t.test(n):"string"==typeof t&&-1!==n.indexOf(t)}var s=/\s*function(?:\s|\s*\/\*[^(?:*\/)]+\*\/\s*)*([^\(\/]+)/;function a(e){var t="";if(void 0===e.name){var n=String(e).match(s);n&&(t=n[1]);}else t=e.name;return t}function c(e){var t=e;return e instanceof Error?t=a(e.constructor):"function"==typeof e&&(t=a(e).trim()||a(new e)),t}function u(e){var t="";return e&&e.message?t=e.message:"string"==typeof e&&(t=e),t}t.exports={compatibleInstance:o,compatibleConstructor:r,compatibleMessage:i,getMessage:u,getConstructorName:c};},{}],36:[function(e,t,n){
/*!
 * deep-eql
 * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var o=e("type-detect");function r(){this._key="chai/deep-eql__"+Math.random()+Date.now();}r.prototype={get:function(e){return e[this._key]},set:function(e,t){Object.isExtensible(e)&&Object.defineProperty(e,this._key,{value:t,configurable:!0});}};var i="function"==typeof WeakMap?WeakMap:r;
/*!
 * Check to see if the MemoizeMap has recorded a result of the two operands
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {MemoizeMap} memoizeMap
 * @returns {Boolean|null} result
*/function s(e,t,n){if(!n||O(e)||O(t))return null;var o=n.get(e);if(o){var r=o.get(t);if("boolean"==typeof r)return r}return null}
/*!
 * Set the result of the equality into the MemoizeMap
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {MemoizeMap} memoizeMap
 * @param {Boolean} result
*/function a(e,t,n,o){if(n&&!O(e)&&!O(t)){var r=n.get(e);r?r.set(t,o):((r=new i).set(t,o),n.set(e,r));}}
/*!
 * Primary Export
 */function c(e,t,n){if(n&&n.comparator)return f(e,t,n);var o=u(e,t);return null!==o?o:f(e,t,n)}function u(e,t){return e===t?0!==e||1/e==1/t:e!=e&&t!=t||!O(e)&&!O(t)&&null}
/*!
 * The main logic of the `deepEqual` function.
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Object} [options] (optional) Additional options
 * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.
 * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of
    complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular
    references to blow the stack.
 * @return {Boolean} equal match
*/function f(e,t,n){(n=n||{}).memoize=!1!==n.memoize&&(n.memoize||new i);var r=n&&n.comparator,c=s(e,t,n.memoize);if(null!==c)return c;var f=s(t,e,n.memoize);if(null!==f)return f;if(r){var l=r(e,t);if(!1===l||!0===l)return a(e,t,n.memoize,l),l;var h=u(e,t);if(null!==h)return h}var d=o(e);if(d!==o(t))return a(e,t,n.memoize,!1),!1;a(e,t,n.memoize,!0);var y=p(e,t,d,n);return a(e,t,n.memoize,y),y}function p(e,t,n,o){switch(n){case"String":case"Number":case"Boolean":case"Date":return c(e.valueOf(),t.valueOf());case"Promise":case"Symbol":case"function":case"WeakMap":case"WeakSet":case"Error":return e===t;case"Arguments":case"Int8Array":case"Uint8Array":case"Uint8ClampedArray":case"Int16Array":case"Uint16Array":case"Int32Array":case"Uint32Array":case"Float32Array":case"Float64Array":case"Array":return d(e,t,o);case"RegExp":return l(e,t);case"Generator":return y(e,t,o);case"DataView":return d(new Uint8Array(e.buffer),new Uint8Array(t.buffer),o);case"ArrayBuffer":return d(new Uint8Array(e),new Uint8Array(t),o);case"Set":case"Map":return h(e,t,o);default:return x(e,t,o)}}
/*!
 * Compare two Regular Expressions for equality.
 *
 * @param {RegExp} leftHandOperand
 * @param {RegExp} rightHandOperand
 * @return {Boolean} result
 */function l(e,t){return e.toString()===t.toString()}
/*!
 * Compare two Sets/Maps for equality. Faster than other equality functions.
 *
 * @param {Set} leftHandOperand
 * @param {Set} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */function h(e,t,n){if(e.size!==t.size)return !1;if(0===e.size)return !0;var o=[],r=[];return e.forEach((function(e,t){o.push([e,t]);})),t.forEach((function(e,t){r.push([e,t]);})),d(o.sort(),r.sort(),n)}
/*!
 * Simple equality for flat iterable objects such as Arrays, TypedArrays or Node.js buffers.
 *
 * @param {Iterable} leftHandOperand
 * @param {Iterable} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */function d(e,t,n){var o=e.length;if(o!==t.length)return !1;if(0===o)return !0;for(var r=-1;++r<o;)if(!1===c(e[r],t[r],n))return !1;return !0}
/*!
 * Simple equality for generator objects such as those returned by generator functions.
 *
 * @param {Iterable} leftHandOperand
 * @param {Iterable} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */function y(e,t,n){return d(w(e),w(t),n)}
/*!
 * Determine if the given object has an @@iterator function.
 *
 * @param {Object} target
 * @return {Boolean} `true` if the object has an @@iterator function.
 */function b(e){return "undefined"!=typeof Symbol&&"object"==typeof e&&void 0!==Symbol.iterator&&"function"==typeof e[Symbol.iterator]}
/*!
 * Gets all iterator entries from the given Object. If the Object has no @@iterator function, returns an empty array.
 * This will consume the iterator - which could have side effects depending on the @@iterator implementation.
 *
 * @param {Object} target
 * @returns {Array} an array of entries from the @@iterator function
 */function g(e){if(b(e))try{return w(e[Symbol.iterator]())}catch(e){return []}return []}
/*!
 * Gets all entries from a Generator. This will consume the generator - which could have side effects.
 *
 * @param {Generator} target
 * @returns {Array} an array of entries from the Generator.
 */function w(e){for(var t=e.next(),n=[t.value];!1===t.done;)t=e.next(),n.push(t.value);return n}
/*!
 * Gets all own and inherited enumerable keys from a target.
 *
 * @param {Object} target
 * @returns {Array} an array of own and inherited enumerable keys from the target.
 */function m(e){var t=[];for(var n in e)t.push(n);return t}
/*!
 * Determines if two objects have matching values, given a set of keys. Defers to deepEqual for the equality check of
 * each key. If any value of the given key is not equal, the function will return false (early).
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Array} keys An array of keys to compare the values of leftHandOperand and rightHandOperand against
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */function v(e,t,n,o){var r=n.length;if(0===r)return !0;for(var i=0;i<r;i+=1)if(!1===c(e[n[i]],t[n[i]],o))return !1;return !0}
/*!
 * Recursively check the equality of two Objects. Once basic sameness has been established it will defer to `deepEqual`
 * for each enumerable key in the object.
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */function x(e,t,n){var o=m(e),r=m(t);if(o.length&&o.length===r.length)return o.sort(),r.sort(),!1!==d(o,r)&&v(e,t,o,n);var i=g(e),s=g(t);return i.length&&i.length===s.length?(i.sort(),s.sort(),d(i,s,n)):0===o.length&&0===i.length&&0===r.length&&0===s.length}
/*!
 * Returns true if the argument is a primitive.
 *
 * This intentionally returns true for all objects that can be compared by reference,
 * including functions and symbols.
 *
 * @param {Mixed} value
 * @return {Boolean} result
 */function O(e){return null===e||"object"!=typeof e}t.exports=c,t.exports.MemoizeMap=i;},{"type-detect":39}],37:[function(e,t,n){var o=Function.prototype.toString,r=/\s*function(?:\s|\s*\/\*[^(?:*\/)]+\*\/\s*)*([^\s\(\/]+)/;function i(e){if("function"!=typeof e)return null;var t="";if(void 0===Function.prototype.name&&void 0===e.name){var n=o.call(e).match(r);n&&(t=n[1]);}else t=e.name;return t}t.exports=i;},{}],38:[function(e,t,n){function o(e,t){return null!=e&&t in Object(e)}function r(e){return e.replace(/([^\\])\[/g,"$1.[").match(/(\\\.|[^.]+?)+/g).map((function(e){if("constructor"===e||"__proto__"===e||"prototype"===e)return {};var t=/^\[(\d+)\]$/.exec(e);return t?{i:parseFloat(t[1])}:{p:e.replace(/\\([.[\]])/g,"$1")}}))}function i(e,t,n){var o=e,r=null;n=void 0===n?t.length:n;for(var i=0;i<n;i++){var s=t[i];o&&(o=void 0===s.p?o[s.i]:o[s.p],i===n-1&&(r=o));}return r}function s(e,t,n){for(var o=e,r=n.length,i=null,s=0;s<r;s++){var a=null,c=null;if(i=n[s],s===r-1)o[a=void 0===i.p?i.i:i.p]=t;else if(void 0!==i.p&&o[i.p])o=o[i.p];else if(void 0!==i.i&&o[i.i])o=o[i.i];else {var u=n[s+1];a=void 0===i.p?i.i:i.p,c=void 0===u.p?[]:{},o[a]=c,o=o[a];}}}function a(e,t){var n=r(t),s=n[n.length-1],a={parent:n.length>1?i(e,n,n.length-1):e,name:s.p||s.i,value:i(e,n)};return a.exists=o(a.parent,a.name),a}function c(e,t){return a(e,t).value}function u(e,t,n){return s(e,n,r(t)),e}t.exports={hasProperty:o,getPathInfo:a,getPathValue:c,setPathValue:u};},{}],39:[function(t,n,o){!function(e,t){"object"==typeof o&&void 0!==n?n.exports=t():e.typeDetect=t();}(this,(function(){var t="function"==typeof Promise,n="object"==typeof self?self:e$3,o="undefined"!=typeof Symbol,r="undefined"!=typeof Map,i="undefined"!=typeof Set,s="undefined"!=typeof WeakMap,a="undefined"!=typeof WeakSet,c="undefined"!=typeof DataView,u=o&&void 0!==Symbol.iterator,f=o&&void 0!==Symbol.toStringTag,p=i&&"function"==typeof Set.prototype.entries,l=r&&"function"==typeof Map.prototype.entries,h=p&&Object.getPrototypeOf((new Set).entries()),d=l&&Object.getPrototypeOf((new Map).entries()),y=u&&"function"==typeof Array.prototype[Symbol.iterator],b=y&&Object.getPrototypeOf([][Symbol.iterator]()),g=u&&"function"==typeof String.prototype[Symbol.iterator],w=g&&Object.getPrototypeOf(""[Symbol.iterator]()),m=8,v=-1;function x(e){var o=typeof e;if("object"!==o)return o;if(null===e)return "null";if(e===n)return "global";if(Array.isArray(e)&&(!1===f||!(Symbol.toStringTag in e)))return "Array";if("object"==typeof window&&null!==window){if("object"==typeof window.location&&e===window.location)return "Location";if("object"==typeof window.document&&e===window.document)return "Document";if("object"==typeof window.navigator){if("object"==typeof window.navigator.mimeTypes&&e===window.navigator.mimeTypes)return "MimeTypeArray";if("object"==typeof window.navigator.plugins&&e===window.navigator.plugins)return "PluginArray"}if(("function"==typeof window.HTMLElement||"object"==typeof window.HTMLElement)&&e instanceof window.HTMLElement){if("BLOCKQUOTE"===e.tagName)return "HTMLQuoteElement";if("TD"===e.tagName)return "HTMLTableDataCellElement";if("TH"===e.tagName)return "HTMLTableHeaderCellElement"}}var u=f&&e[Symbol.toStringTag];if("string"==typeof u)return u;var p=Object.getPrototypeOf(e);return p===RegExp.prototype?"RegExp":p===Date.prototype?"Date":t&&p===Promise.prototype?"Promise":i&&p===Set.prototype?"Set":r&&p===Map.prototype?"Map":a&&p===WeakSet.prototype?"WeakSet":s&&p===WeakMap.prototype?"WeakMap":c&&p===DataView.prototype?"DataView":r&&p===d?"Map Iterator":i&&p===h?"Set Iterator":y&&p===b?"Array Iterator":g&&p===w?"String Iterator":null===p?"Object":Object.prototype.toString.call(e).slice(m,v)}return x}));},{}]},{},[1])(1);o$1.version;o$1.AssertionError;o$1.use;o$1.util;o$1.config;o$1.Assertion;o$1.expect;o$1.should;o$1.Should;var h=o$1.assert;

const DEFAULT_IGNORE_TAGS = ['script', 'style', 'svg'];
const DEFAULT_EMPTY_ATTRS = ['class', 'id'];
const VOID_ELEMENTS = [
  'area',
  'base',
  'br',
  'col',
  'embed',
  'hr',
  'img',
  'input',
  'keygen',
  'link',
  'menuitem',
  'meta',
  'param',
  'source',
  'track',
  'wbr',
];

/**
 * Reverses the sense of a predicate
 * @param  {(x: any) => Boolean} p predicate
 * @return {(x: any) => Boolean}
 */
const not = p => (...args) => !p(...args);

/**
 * @typedef IgnoreAttributesForTags
 * @property {string[]} tags tags on which to ignore the given attributes
 * @property {string[]} attributes attributes to ignore for the given tags
 */

/**
 * @typedef DiffOptions
 * @property {(string | IgnoreAttributesForTags)[]} [ignoreAttributes]
 *  array of attributes to ignore, when given a string that attribute will be ignored on all tags
 *  when given an object of type `IgnoreAttributesForTags`, you can specify on which tags to ignore which attributes
 * @property {string[]} [ignoreTags] array of tags to ignore, these tags are stripped from the output
 * @property {string[]} [ignoreChildren] array of tags whose children to ignore, the children of
 *   these tags are stripped from the output
 * @property {string[]} [stripEmptyAttributes] array of attributes which should be removed when empty.
 *   Be careful not to add any boolean attributes here (e.g. `hidden`) unless you know what you're doing
 */

/**
 * Restructures given HTML string, returning it in a format which can be used for comparison:
 * - whitespace and newlines are normalized
 * - tags and attributes are printed on individual lines
 * - comments, style, script and svg tags are removed
 * - additional tags and attributes can optionally be ignored
 *
 * See README.md for details.
 *
 * @example
 * import getDiffableHTML from '@open-wc/semantic-dom-diff';
 *
 * const htmlA = getDiffableHTML(`... some html ...`, { ignoredAttributes: [], ignoredTags: [], ignoreChildren: [] });
 * const htmlB = getDiffableHTML(`... some html ...`);
 *
 * // use regular string comparison to spot the differences
 * expect(htmlA).to.equal(htmlB);
 *
 * @param {Node | string} html
 * @param {DiffOptions} [options]
 * @returns {string} html restructured in a diffable format
 */
function getDiffableHTML(html, options = {}) {
  const ignoreAttributes = /** @type {string[]} */ (options.ignoreAttributes
    ? options.ignoreAttributes.filter(e => typeof e === 'string')
    : []);
  const ignoreAttributesForTags = /** @type {IgnoreAttributesForTags[]} */ (options.ignoreAttributes
    ? options.ignoreAttributes.filter(e => typeof e !== 'string')
    : []);
  const ignoreTags = [...(options.ignoreTags || []), ...DEFAULT_IGNORE_TAGS];
  const ignoreChildren = options.ignoreChildren || [];
  const stripEmptyAttributes = options.stripEmptyAttributes || DEFAULT_EMPTY_ATTRS;
  const escapeAttributes = /(&|")/g;
  /** @param {string} match */
  const escapeAttributesFn = match => (match === '&' ? '&amp;' : '&quot;');

  let text = '';
  let depth = -1;
  /** @type {Set<Node>} */
  const handledChildrenForNode = new Set();
  /** @type {Set<Node>} */
  const handledNodeStarted = new Set();

  /** @returns {string} */
  function getIndentation() {
    return '  '.repeat(depth);
  }

  /**
   * @param {Text} textNode
   * @param {TreeWalker} walker
   */
  function printText(textNode, walker) {
    let value = '';
    let node = textNode;

    while (node && node instanceof Text) {
      value += node.nodeValue;

      node = walker.nextSibling();
    }

    if (node) {
      walker.previousSibling();
    }

    value = value.trim();

    if (value !== '') {
      text += `${getIndentation()}${value}\n`;
    }
  }

  /** @param {Node} node */
  function getTagName(node) {
    // Use original tag if available via data-tag-name attribute (use-case for scoped elements)
    // See packages/scoped-elements for more info
    if (node instanceof Element) {
      return node.getAttribute('data-tag-name') || node.localName;
    }
    return node.nodeName.toLowerCase();
  }

  /** @param {Node} node */
  function shouldProcessChildren(node) {
    const name = getTagName(node);
    return (
      !ignoreTags.includes(name) &&
      !ignoreChildren.includes(name) &&
      !handledChildrenForNode.has(node)
    );
  }

  /**
   * An element's classList, sorted, as string
   * @param  {Element} el Element
   * @return {String}
   */
  function getClassListValueString(el) {
    // @ts-ignore
    return [...el.classList.values()].sort().join(' ');
  }

  function shouldStripAttribute({ name, value }) {
    return stripEmptyAttributes.includes(name) && value.trim() === '';
  }

  /**
   * @param {Element} el
   * @param {Attr} attr
   */
  function getAttributeString(el, { name, value }) {
    if (shouldStripAttribute({ name, value })) return '';
    if (name === 'class') return ` class="${getClassListValueString(el)}"`;
    return ` ${name}="${value.replace(escapeAttributes, escapeAttributesFn)}"`;
  }

  /**
   * @param {Element} el
   * @return {(attr: Attr) => Boolean}
   */
  function isIgnoredAttribute(el) {
    return function isIgnoredElementAttibute(attr) {
      if (ignoreAttributes.includes(attr.name) || shouldStripAttribute(attr)) {
        return true;
      }

      return !!ignoreAttributesForTags.find(e => {
        if (!e.tags || !e.attributes) {
          throw new Error(
            `An object entry to ignoreAttributes should contain a 'tags' and an 'attributes' property.`,
          );
        }
        return e.tags.includes(getTagName(el)) && e.attributes.includes(attr.name);
      });
    };
  }

  const sortAttribute = (a, b) => a.name.localeCompare(b.name);

  /** @param {Element} el */
  function getAttributesString(el) {
    let attrStr = '';
    const attributes = Array.from(el.attributes)
      .filter(not(isIgnoredAttribute(el)))
      .sort(sortAttribute);

    if (attributes.length === 1) {
      attrStr = getAttributeString(el, attributes[0]);
    } else if (attributes.length > 1) {
      for (let i = 0; i < attributes.length; i += 1) {
        attrStr += `\n${getIndentation()} ${getAttributeString(el, attributes[i])}`;
      }
      attrStr += `\n${getIndentation()}`;
    }

    return attrStr;
  }

  /** @param {Element} el */
  function printOpenElement(el) {
    text += `${getIndentation()}<${getTagName(el)}${getAttributesString(el)}>\n`;
  }

  /**
   * @param {Node} node
   * @param {TreeWalker} walker
   */
  function onNodeStart(node, walker) {
    // don't print this node if we should ignore it
    if (getTagName(node) === 'diff-container' || ignoreTags.includes(getTagName(node))) {
      return;
    }

    // don't print this node if it was already printed, this happens when
    // crawling upwards after handling children
    if (handledNodeStarted.has(node)) {
      return;
    }
    handledNodeStarted.add(node);

    if (node instanceof Text) {
      printText(node, walker);
    } else if (node instanceof Element) {
      printOpenElement(node);
    } else {
      throw new Error(`Unknown node type: ${node}`);
    }
  }

  /** @param {Element} el */
  function printCloseElement(el) {
    if (getTagName(el) === 'diff-container' || VOID_ELEMENTS.includes(getTagName(el))) {
      return;
    }

    text += `${getIndentation()}</${getTagName(el)}>\n`;
  }

  /** @param {Node} node */
  function onNodeEnd(node) {
    // don't print this node if we should ignore it
    if (ignoreTags.includes(getTagName(node))) {
      return;
    }

    if (node instanceof Element) {
      printCloseElement(node);
    }
  }

  let container;

  if (typeof html === 'string') {
    container = document.createElement('diff-container');
    container.innerHTML = html;
    depth = -1;
  } else if (html instanceof Node) {
    container = html;
    depth = 0;
  } else {
    throw new Error(`Cannot create diffable HTML from: ${html}`);
  }

  const walker = document.createTreeWalker(
    container,
    NodeFilter.SHOW_TEXT + NodeFilter.SHOW_ELEMENT,
    null,
    false,
  );

  // walk the dom and create a diffable string representation
  while (walker.currentNode) {
    const current = walker.currentNode;
    onNodeStart(current, walker);

    // crawl children if we should for this node, and if it has children
    if (shouldProcessChildren(current) && walker.firstChild()) {
      depth += 1;
    } else {
      // we are done processing this node's children, handle this node's end
      onNodeEnd(current);

      // move to next sibling
      const sibling = walker.nextSibling();

      // otherwise move back up to parent node
      if (!sibling) {
        depth -= 1;

        const parent = walker.parentNode();
        // if there is no parent node, we are done
        if (!parent) {
          break;
        }

        // we just processed the parent's children, remember so that we don't
        // process them again later
        handledChildrenForNode.add(parent);
      }
    }
  }

  return text;
}

/**
 * @param {*} arg
 * @return {arg is DiffOptions}
 */
function isDiffOptions(arg) {
  return (
    arg &&
    arg !== null &&
    typeof arg === 'object' &&
    ('ignoreAttributes' in arg ||
      'ignoreTags' in arg ||
      'ignoreChildren' in arg ||
      'stripEmptyAttributes' in arg)
  );
}

/* eslint-env browser, es2020 */
const PARAM_SESSION_ID = 'wtr-session-id';

const sessionId = new URL(window.location.href).searchParams.get(PARAM_SESSION_ID);

function isObject(payload) {
  return payload != null && typeof payload === 'object';
}

async function executeServerCommand(command, payload, pluginName) {
  if (typeof sessionId !== 'string') {
    throw new Error(
      'Unable to execute server commands in a browser not controlled by the test runner. ' +
        'Use the debug option from the watch menu to debug in a controlled browser.',
    );
  }

  let sendMessageWaitForResponse;
  try {
    const webSocketModule = await import('../../../../../__web-dev-server__web-socket.js');
    ({ sendMessageWaitForResponse } = webSocketModule);
  } catch (error) {
    throw new Error(
      'Could not setup web socket connection. Are you executing this test through Web Test Runner?',
    );
  }

  try {
    const response = await sendMessageWaitForResponse({
      type: 'wtr-command',
      sessionId,
      command,
      payload,
    });

    if (!response.executed) {
      let msg;
      if (pluginName) {
        msg = `Unknown command ${command}. Add the ${pluginName} to your config.`;
      } else {
        msg = `Unknown command ${command}. Did you install a plugin to handle this command?`;
      }
      throw new Error(msg);
    }

    return response.result;
  } catch (error) {
    throw new Error(
      `Error while executing command ${command}${
        payload ? ` with payload ${JSON.stringify(payload)}` : ''
      }: ${error.message}`,
    );
  }
}

let snapshotConfig;
let cachedSnapshots;

async function getSnapshotConfig() {
  if (!snapshotConfig) {
    snapshotConfig = await executeServerCommand(
      'get-snapshot-config',
      undefined,
      'snapshotPlugin from @web/test-runner-commands',
    );
  }

  return snapshotConfig;
}

/**
 * This regexp is used to capture the snapshots contents.
 *
 * snapshots\[[^\]]+] = (\n)? - snapshot definition. Sometimes the initial content backtick is placed in the next line
 * (?<content>`[^`]+`) - capture the snapshot content, which is included between backticks "`"
 * /gm - global and multiline
 * @type {RegExp}
 */
const ESCAPE_REGEX = /snapshots\[[^\]]+] = (\n)?(?<content>`[^`]*`)/gm;

const escapeContent = content => {
  [...content.matchAll(ESCAPE_REGEX)].forEach(({ groups: { content: itemContent } }) => {
    content = content.replaceAll(itemContent, encodeURIComponent(itemContent));
  });

  return content;
};

async function getSnapshots({ cache = true } = {}) {
  if (cache && cachedSnapshots) {
    return cachedSnapshots;
  }

  const result = await executeServerCommand(
    'get-snapshots',
    undefined,
    'snapshotPlugin from @web/test-runner-commands',
  );

  if (typeof result?.content !== 'string') {
    throw new Error('Expected a result as string');
  }

  const content = `${escapeContent(result.content)}/* ${Math.random()} */`;
  const module = await import(`data:text/javascript;charset=utf-8,${content}`);

  if (!module || !isObject(module.snapshots)) {
    throw new Error('Expected snapshot result to be a module that exports an object.');
  }

  cachedSnapshots = module.snapshots;

  return cachedSnapshots;
}

async function getSnapshot(options) {
  if (!isObject(options)) throw new Error('You must provide a payload object');
  if (typeof options.name !== 'string') throw new Error('You must provide a snapshot name');

  const snapshots = await getSnapshots(options);

  return snapshots[options.name];
}

async function saveSnapshot(options) {
  if (!isObject(options)) throw new Error('You must provide a payload object');
  if (typeof options.name !== 'string') throw new Error('You must provide a snapshot name');
  if (options.content !== undefined && typeof options.content !== 'string')
    throw new Error('You must provide a snapshot content');

  // ensure snapshots for this file are loaded
  const snapshots = await getSnapshots();

  // store snapshot in-memory
  snapshots[options.name] = options.content;

  return executeServerCommand(
    'save-snapshot',
    options,
    'snapshotPlugin from @web/test-runner-commands',
  );
}

// @ts-nocheck

/**
 * el.outerHTML is not polyfilled so we need to recreate the tag + attributes and
 * combine it with el.innerHTML.
 *
 * @param {Element} el Element you want to get the out Html from
 * @returns {String} outer html
 */
const getOuterHtml = el => {
  /* istanbul ignore next */
  if (window.ShadyCSS && window.ShadyCSS.nativeShadow === false) {
    const tagName = el.tagName.toLowerCase();
    let attributes = ' ';
    Array.prototype.slice.call(el.attributes).forEach(item => {
      attributes += `${item.name}="${item.value}" `;
    });
    // removes last ' ' or if there are no attributes makes it to equal ''
    attributes = attributes.slice(0, -1);
    return `<${tagName}${attributes}>${el.innerHTML}</${tagName}>`;
  }
  return el.outerHTML;
};

/**
 * For comparison we do not need the style scoping classes on polyfilled browsers
 * Rather naive approach for now - probably need to improve once we have failing cases.
 *
 * @param {Element} el Element you want to get the cleaned shadow dom
 * @returns {String} cleaned shadow dom
 */
const getCleanedShadowDom = el => {
  /* istanbul ignore next */
  if (window.ShadyCSS && window.ShadyCSS.nativeShadow === false) {
    const tagName = el.tagName.toLowerCase();
    const regexTagName = new RegExp(tagName, 'g');
    let domString = el.shadowRoot.innerHTML;
    domString = domString.replace(/style-scope/g, ''); // remove style-scope class
    domString = domString.replace(regexTagName, ''); // remove scoped class name
    domString = domString.replace(/(class=".*?)(\s)*"/g, '$1"'); // remove trailing spaces in class=" "
    domString = domString.replace(/ class="\w?"/g, ''); // remove empty class attributes
    return domString;
  }
  return el.shadowRoot.innerHTML;
};

function getMochaTestPath(runnable) {
  const path = [];
  let node;
  if (runnable.type === 'hook') {
    node = runnable.ctx.currentTest;
  } else {
    node = runnable;
  }

  while (node && node.parent) {
    if (node.title) {
      path.push(node.title);
    }
    node = node.parent;
  }
  return path.reverse();
}

/* eslint-disable no-param-reassign */

/** @typedef {import('./get-diffable-html.js').DiffOptions} DiffOptions */

function disambiguateArgs(...args) {
  switch (args.length) {
    // equal<T>(actual: T, expected: T, message?: string, options?: DiffOptions): void;
    case 2: {
      const [message, options] = args;
      return { message, options };
    }

    // equal<T>(actual: T, expected: T, message?: string): void;
    // equal<T>(actual: T, expected: T, options?: DiffOptions): void;
    case 1: {
      const [first] = args;
      return isDiffOptions(first) ? { options: first } : { message: first };
    }

    default:
      return {};
  }
}

/**
 * @type {Chai.ChaiPlugin}
 */
const chaiDomDiff = (chai, utils) => {
  /**
   * can not be an arrow function as it gets rebound by chai
   */
  chai.Assertion.addProperty('lightDom', function lightDom() {
    new chai.Assertion(this._obj.nodeType).to.equal(1);
    utils.flag(this, 'lightDom', true);
  });

  /**
   * can not be an arrow function as it gets rebound by chai
   */
  chai.Assertion.addProperty('shadowDom', function shadowDom() {
    new chai.Assertion(this._obj.nodeType).to.equal(1);
    utils.flag(this, 'shadowDom', true);
  });

  /**
   * can not be an arrow function as it gets rebound by chai
   */
  chai.Assertion.addProperty('dom', function dom() {
    new chai.Assertion(this._obj.nodeType).to.equal(1);
    utils.flag(this, 'dom', true);
  });

  const getDomHtml = el => getOuterHtml(el);
  const getLightDomHtml = el => el.innerHTML;
  const getShadowDomHtml = el => getCleanedShadowDom(el);

  /**
   * Base HTML assertion for `assert` interface.
   * @param {string | Node} actual
   * @param {string | Node} expected
   * @param {boolean} negate
   * @param {[string]|[DiffOptions]|[string, DiffOptions]} rest
   */
  const assertHtmlEquals = (actual, expected, negate, ...rest) => {
    const { message, options } = disambiguateArgs(...rest);
    // use chai's built-in string comparison, log the updated snapshot on error
    const assertion = new chai.Assertion(getDiffableHTML(actual, options), message);
    const expectedDiffableHTML = getDiffableHTML(expected, options);

    if (negate) {
      assertion.not.equal(expectedDiffableHTML, message);
    } else {
      assertion.equal(expectedDiffableHTML, message);
    }
  };

  /** DOM assertion for `should` and `expect` interfaces. */
  const domEquals = _super =>
    /**
     * @this {Chai.AssertionStatic}
     */
    function handleDom(value, ...args) {
      if (
        utils.flag(this, 'lightDom') ||
        utils.flag(this, 'shadowDom') ||
        utils.flag(this, 'dom')
      ) {
        let html;
        if (utils.flag(this, 'lightDom')) {
          html = getLightDomHtml(this._obj);
        } else if (utils.flag(this, 'shadowDom')) {
          html = getShadowDomHtml(this._obj);
        } else {
          html = getDomHtml(this._obj);
        }

        assertHtmlEquals(html, value, utils.flag(this, 'negate'), args[0]);
      } else {
        _super.apply(this, [value, ...args]);
      }
    };

  chai.Assertion.overwriteMethod('equals', domEquals);
  chai.Assertion.overwriteMethod('equal', domEquals);
  chai.Assertion.overwriteMethod('eq', domEquals);

  /**
   * Base HTML snapshot assertion for `assert` interface.
   * @this {Chai.AssertionStatic}
   * @param {string|Node} actual
   * @param {boolean} negate
   * @param {[string]|[DiffOptions]|[string, DiffOptions]} rest
   */
  function assertHtmlEqualsSnapshotKarma(actual, negate, ...rest) {
    const context = window.__mocha_context__;
    const snapshotState = window.__snapshot__;

    const { message, options } = disambiguateArgs(...rest);
    const { index } = context;
    context.index += 1;
    const path = getMochaTestPath(context.runnable);
    const html = getDiffableHTML(actual, options);

    if (snapshotState.update) {
      snapshotState.set(path, index, html, 'html');
    } else {
      const snapshot = snapshotState.get(path, index);

      if (!snapshot) {
        snapshotState.set(path, index, html, 'html');
      } else {
        const isMatch = snapshotState.match(html, getDiffableHTML(snapshot.code, options));
        if ((isMatch && negate) || (!isMatch && !negate)) {
          /* istanbul ignore next */
          throw new chai.AssertionError(
            message || `Received value does not match stored snapshot ${index}`,
            {
              actual: html,
              expected: snapshot.code,
              showDiff: true,
            },
            chai.util.flag(this, 'ssfi'),
          );
        }
      }
    }
  }

  /**
   * Base HTML snapshot assertion for `assert` interface.
   * @this {Chai.AssertionStatic}
   * @param {string|Node} actual
   * @param {boolean} negate
   * @param {[string]|[DiffOptions]|[string, DiffOptions]} rest
   */
  async function assertHtmlEqualsSnapshotWebTestRunner(actual, negate, ...rest) {
    const { message, options } = disambiguateArgs(...rest);
    const path = getMochaTestPath(window.__WTR_MOCHA_RUNNER__.test);
    const name = path.join(' ');
    const snapshot = getDiffableHTML(actual, options);
    const currentSnapshot = await getSnapshot({ name });
    const config = await getSnapshotConfig();

    if (currentSnapshot && !config.updateSnapshots) {
      if (negate ? currentSnapshot === snapshot : currentSnapshot !== snapshot) {
        throw new chai.AssertionError(
          message || `Snapshot ${name} does not match the saved snapshot on disk`,
          {
            actual: snapshot,
            expected: currentSnapshot,
            showDiff: true,
          },
          chai.util.flag(this, 'ssfi'),
        );
      }
    } else if (currentSnapshot !== snapshot) {
      await saveSnapshot({ name, content: snapshot });
    }
  }

  function assertHtmlEqualsSnapshot(actual, negate, ...rest) {
    if (window.__mocha_context__ && window.__snapshot__) {
      return assertHtmlEqualsSnapshotKarma.call(this, actual, negate, ...rest);
    }
    if (window.__WTR_MOCHA_RUNNER__) {
      return assertHtmlEqualsSnapshotWebTestRunner.call(this, actual, negate, ...rest);
    }
    throw new Error(
      'Could not detect test runner environment. ' +
        'Snapshots require either Web Test Runner with mocha, ' +
        'or Karma with mocha and karma mocha snapshot',
    );
  }

  /**
   * Snapshot assertion for `should` and `expect` interfaces.
   * @this {Chai.AssertionStatic}
   */
  function equalSnapshot(options) {
    const el = chai.util.flag(this, 'object');
    let html;
    if (utils.flag(this, 'shadowDom')) {
      html = getShadowDomHtml(el);
    } else if (utils.flag(this, 'lightDom')) {
      html = getLightDomHtml(el);
    } else {
      html = el;
    }
    return assertHtmlEqualsSnapshot.call(this, html, utils.flag(this, 'negate'), options);
  }

  utils.addMethod(chai.Assertion.prototype, 'equalSnapshot', equalSnapshot);
  utils.addMethod(chai.Assertion.prototype, 'notEqualSnapshot', equalSnapshot);

  utils.addMethod(chai.assert, 'equalSnapshot', assertHtmlEqualsSnapshot);
  utils.addMethod(chai.assert, 'notEqualSnapshot', assertHtmlEqualsSnapshot);

  /** @type {Chai.Assert['dom']} */
  chai.assert.dom = {
    equal(actualEl, expectedHTML, ...rest) {
      const negate = false;
      return assertHtmlEquals.call(this, getDomHtml(actualEl), expectedHTML, negate, ...rest);
    },
    notEqual(actualEl, expectedHTML, ...rest) {
      const negate = true;
      return assertHtmlEquals.call(this, getDomHtml(actualEl), expectedHTML, negate, ...rest);
    },
    equalSnapshot(actualEl, ...rest) {
      const negate = false;
      return assertHtmlEqualsSnapshot.call(this, actualEl, negate, ...rest);
    },
    notEqualSnapshot(actualEl, ...rest) {
      const negate = true;
      return assertHtmlEqualsSnapshot.call(this, actualEl, negate, ...rest);
    },
  };

  /** @type {Chai.Assert['lightDom']} */
  chai.assert.lightDom = {
    equal(actualEl, expectedHTML, ...rest) {
      const negate = false;
      return assertHtmlEquals.call(this, getLightDomHtml(actualEl), expectedHTML, negate, ...rest);
    },
    notEqual(actualEl, expectedHTML, ...rest) {
      const negate = true;
      return assertHtmlEquals.call(this, getLightDomHtml(actualEl), expectedHTML, negate, ...rest);
    },
    equalSnapshot(actualEl, ...rest) {
      const negate = false;
      return assertHtmlEqualsSnapshot.call(this, getLightDomHtml(actualEl), negate, ...rest);
    },
    notEqualSnapshot(actualEl, ...rest) {
      const negate = true;
      return assertHtmlEqualsSnapshot.call(this, getLightDomHtml(actualEl), negate, ...rest);
    },
  };

  /** @type {Chai.Assert['shadowDom']} */
  chai.assert.shadowDom = {
    equal(actualEl, expectedHTML, ...rest) {
      const negate = false;
      return assertHtmlEquals.call(this, getShadowDomHtml(actualEl), expectedHTML, negate, ...rest);
    },
    notEqual(actualEl, expectedHTML, ...rest) {
      const negate = true;
      return assertHtmlEquals.call(this, getShadowDomHtml(actualEl), expectedHTML, negate, ...rest);
    },
    equalSnapshot(actualEl, ...rest) {
      const negate = false;
      return assertHtmlEqualsSnapshot.call(this, getShadowDomHtml(actualEl), negate, ...rest);
    },
    notEqualSnapshot(actualEl, ...rest) {
      const negate = true;
      return assertHtmlEqualsSnapshot.call(this, getShadowDomHtml(actualEl), negate, ...rest);
    },
  };
};

// @ts-nocheck
/**
 * In the browser, importing axe-core/axe.min.js will register to the window. In webpack it will
 * be parsed as a commonjs module, so it won't be on the window. In this file we conditionally
 * export from the window, or a webpack specific module import.
 */

/* eslint-disable global-require, import/no-mutable-exports */
let axe;

async function loadAxe() {
  if (window.axe) {
    // axe was already imported before
    axe = window.axe;
    return;
  }

  if (typeof require === 'function') {
    // we are in a webpack environment
    axe = require('axe-core/axe.min.js');
    return;
  }

  // regular behavior, load axe as an es module and let it
  // register to the window
  await import('./axe.min-ecbbbb8e.js').then(function (n) { return n.a; });
  if (!window.axe) {
    throw new Error(
      'Error importing axe-core/axe.min.js, are you using a bundler or build tool that doesnt handle es modules?',
    );
  }
  axe = window.axe;
}

/**
 * Creates a map of rules to disable during the test.
 * @param {Array<String>?} ignored List of rule names to ignore during the test.
 * @return {Object|undefined} List of rules to be passed to test configuration or
 * `undefined` when not needed.
 */
function getRules(ignored) {
  if (!ignored || !ignored.length) {
    return undefined;
  }
  const result = {};
  ignored.forEach(rule => {
    result[rule] = { enabled: false };
  });
  return result;
}

/**
 * Performs the test using AXE core.
 * @param {Element} element The element to be used to perform the test on.
 * @param {Object} opts AXE configuration options.
 * @return {Promise} Promise resolved to the test results object
 */
async function runTestAsync(element, opts) {
  if (!axe) {
    // ensure axe is loaded before running tests
    await loadAxe();
  }

  return new Promise((resolve, reject) => {
    // @ts-ignore
    axe.run(element, opts, (err, results) => {
      if (err) {
        reject(new Error(err));
      } else {
        resolve(results);
      }
    });
  });
}

/**
 * Processes axe testing results.
 * @param {Boolean} negate When true "not" was used with the test and the output is the opposite
 * (failed test won't throw error)
 * @param {Object} results Axe test result object
 * @param {Function} done A function to be called when ready.
 * @throws {Error} When test did not pass.
 */
function processResults(negate, results, done) {
  const { violations } = results;

  if (violations.length && negate) {
    done();
    return;
  }

  if (!violations.length && !negate) {
    done();
    return;
  }

  const messages = [];
  if (violations.length) {
    messages[messages.length] = 'Accessibility Violations';
    messages[messages.length] = '---';
    violations.forEach(violation => {
      messages[messages.length] = `Rule: ${violation.id}`;
      messages[messages.length] = `Impact: ${violation.impact}`;
      messages[messages.length] = `${violation.help} (${violation.helpUrl})`;
      violation.nodes.forEach(node => {
        messages[messages.length] = '';
        if (node.target) {
          messages[messages.length] = `Issue target: ${node.target}`;
        }
        messages[messages.length] = `Context: ${node.html}`;
        if (node.failureSummary) {
          messages[messages.length] = `${node.failureSummary}`;
        }
      });
      messages[messages.length] = '---';
    });
  }

  const msg = new Error(messages.join('\n'));
  done(msg);
  throw msg;
}

/**
 * @param {any} chai
 * @param {any} utils
 */
const chaiA11yAxe = (chai, utils) => {
  const { assert } = chai;
  utils.addMethod(chai.Assertion.prototype, 'accessible', function axeTest(options) {
    // @ts-ignore
    const fixture = this._obj;
    const opts = options || {};

    const rules = getRules(opts.ignoredRules);

    const testOpts = {
      resultTypes: ['violations'],
    };
    if (rules) {
      testOpts.rules = rules;
    }
    let done = opts.done ? opts.done : undefined;
    if (!done) {
      done = () => {};
    }

    if (opts.ignoredTags) {
      const ariaHiddenElements = fixture.parentNode.querySelectorAll(opts.ignoredTags.toString());
      ariaHiddenElements.forEach(el => el.setAttribute('aria-hidden', true));
    }

    const result = runTestAsync(fixture, testOpts).then(results =>
      // @ts-ignore
      processResults(utils.flag(this, 'negate'), results, done),
    );
    // @ts-ignore
    this.then = result.then.bind(result);
    // @ts-ignore
    return this;
  });

  assert.isAccessible = function isAccessible(fixture, options) {
    return new chai.Assertion(fixture).to.be.accessible(options);
  };

  assert.isNotAccessible = function isAccessible(fixture, options) {
    return new chai.Assertion(fixture).not.to.be.accessible(options);
  };
};

function createCommonjsModule$1(fn) {
  var module = { exports: {} };
	return fn(module, module.exports), module.exports;
}

function commonjsRequire$1 (path) {
	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}

var chaiDom = createCommonjsModule$1(function (module, exports) {
(function(chaiDom) {
  if (typeof commonjsRequire$1 === 'function' && 'object' === 'object' && 'object' === 'object') {
    module.exports = chaiDom;
  } else {
    chai.use(chaiDom);
  }
}(function(chai, utils) {
  var flag = utils.flag,

  elToString = function(el) {
    var desc;
    if (isNodeList(el)) {
      if (el.length === 0) {
        return 'empty NodeList'
      }

      desc = Array.prototype.slice.call(el, 0, 5).map(elToString).join(', ');
      return el.length > 5 ? desc + '... (+' + (el.length - 5) + ' more)' : desc
    }
    if (!isHTMLElement(el)) {
      return String(el)
    }

    desc = el.tagName.toLowerCase();
    if (el.id) {
      desc += '#' + el.id;
    }
    if (el.className) {
      desc += '.' + String(el.className).replace(/\s+/g, '.');
    }
    Array.prototype.forEach.call(el.attributes, function(attr) {
      if (attr.name !== 'class' && attr.name !== 'id') {
        desc += '[' + attr.name + (attr.value ? '="' + attr.value + '"]' : ']');
      }
    });
    return desc
  },

  attrAssert = function(name, val) {
    var el = flag(this, 'object'), actual = el.getAttribute(name);

    if (!flag(this, 'negate') || undefined === val) {
      this.assert(
        !!el.attributes[name]
        , 'expected ' + elToString(el) + ' to have an attribute #{exp}'
        , 'expected ' + elToString(el) + ' not to have an attribute #{exp}'
        , name
      );
    }

    if (undefined !== val) {
      this.assert(
        val === actual
        , 'expected ' + elToString(el) + ' to have an attribute ' + utils.inspect(name) + ' with the value #{exp}, but the value was #{act}'
        , 'expected ' + elToString(el) + ' not to have an attribute ' + utils.inspect(name) + ' with the value #{act}'
        , val
        , actual
      );
    }

    flag(this, 'object', actual);
  },

  isHTMLElement = function(el) {
    return el.nodeType === 1 // window.Node.ELEMENT_NODE
  },

  isNodeList = function(obj) {
    return Object.prototype.toString.call(obj) === '[object NodeList]'
  };

  utils.elToString = elToString;
  chai.Assertion.addMethod('attr', attrAssert);
  chai.Assertion.addMethod('attribute', attrAssert);

  chai.Assertion.addMethod('class', function(className) {
    var el = flag(this, 'object');

    if (className instanceof RegExp) {
      return this.assert(
        Array.from(el.classList).some(function(cls) { return className.test(cls) })
        , 'expected ' + elToString(el) + ' to have class matching #{exp}'
        , 'expected ' + elToString(el) + ' not to have class matching #{exp}'
        , className
      )
    } 
    
    this.assert(
      el.classList.contains(className)
      , 'expected ' + elToString(el) + ' to have class #{exp}'
      , 'expected ' + elToString(el) + ' not to have class #{exp}'
      , className
    );
  });

  chai.Assertion.addMethod('id', function(id) {
    var el = flag(this, 'object');
    this.assert(
      el.id == id
      , 'expected ' + elToString(el) + ' to have id #{exp}'
      , 'expected ' + elToString(el) + ' not to have id #{exp}'
      , id
    );
  });

  chai.Assertion.addMethod('html', function(html) {
    var el = flag(this, 'object'), actual = flag(this, 'object').innerHTML;

    if (flag(this, 'contains')) {
      this.assert(
        actual.indexOf(html) >= 0
        , 'expected #{act} to contain HTML #{exp}'
        , 'expected #{act} not to contain HTML #{exp}'
        , html
        , actual
      );
    } else {
      this.assert(
        actual === html
        , 'expected ' + elToString(el) + ' to have HTML #{exp}, but the HTML was #{act}'
        , 'expected ' + elToString(el) + ' not to have HTML #{exp}'
        , html
        , actual
      );
    }
  });

  chai.Assertion.addChainableMethod('trimmed', null, function() {
    flag(this, 'trim-text', true);
  });

  chai.Assertion.addProperty('rendered', function() {
    flag(this, 'rendered-text', true);
  });

  chai.Assertion.addMethod('text', function(text) {
    var obj = flag(this, 'object'), contains = flag(this, 'contains'),
        trim = flag(this, 'trim-text'), actual, result;
    var property = flag(this, 'rendered-text') ? 'innerText' : 'textContent';

    if (isNodeList(obj)) {
      actual = Array.prototype.map.call(obj, function(el) { return trim ? el[property].trim() : el[property] });
      if (Array.isArray(text)) {
        result = contains ?
          text[flag(this, 'negate') ? 'some' : 'every'](function(t) {
            return Array.prototype.some.call(obj, function(el) {
              return (trim ? el[property].trim() : el[property]) === t
            })
          })
          :
          utils.eql(actual, text);

        actual = actual.join();
        text = text.join();
      } else {
        actual = actual.join('');
        result = contains ? actual.indexOf(text) >= 0 : actual === text;
      }
    } else {
      actual = trim ? obj[property].trim() : obj[property];
      result = contains ? actual.indexOf(text) >= 0 : actual === text;
    }

    var objDesc = elToString(obj);
    var textMsg = '';

    if (trim) {
      textMsg += 'trimmed ';
    }
    if (flag(this, 'rendered-text')) {
      textMsg += 'rendered ';
    }
    textMsg += 'text';

    if (contains) {
      this.assert(
        result
        , 'expected ' + objDesc + ' to contain #{exp}, but the ' + textMsg + ' was #{act}'
        , 'expected ' + objDesc + ' not to contain #{exp}, but the ' + textMsg + ' was #{act}'
        , text
        , actual
      );
    } else {
      this.assert(
        result
        , 'expected ' + objDesc + ' to have ' + textMsg + ' #{exp}, but the ' + textMsg + ' was #{act}'
        , 'expected ' + objDesc + ' not to have ' + textMsg + ' #{exp}'
        , text
        , actual
      );
    }
  });

  chai.Assertion.addMethod('value', function(value) {
    var el = flag(this, 'object'), actual = flag(this, 'object').value;
    this.assert(
      flag(this, 'object').value === value
      , 'expected ' + elToString(el) + ' to have value #{exp}, but the value was #{act}'
      , 'expected ' + elToString(el) + ' not to have value #{exp}'
      , value
      , actual
    );
  });

  chai.Assertion.overwriteProperty('exist', function(_super) {
    return function() {
      var obj = flag(this, 'object');
      if (isNodeList(obj)) {
        this.assert(
          obj.length > 0
          , 'expected an empty NodeList to have nodes'
          , 'expected ' + elToString(obj) + ' to not exist');
      } else {
        _super.apply(this, arguments);
      }
    }
  });

  chai.Assertion.overwriteProperty('empty', function(_super) {
    return function() {
      var obj = flag(this, 'object');
      if (isHTMLElement(obj)) {
        this.assert(
          obj.children.length === 0
          , 'expected ' + elToString(obj) + ' to be empty'
          , 'expected ' + elToString(obj) + ' to not be empty');
      } else if (isNodeList(obj)) {
        this.assert(
          obj.length === 0
          , 'expected ' + elToString(obj) + ' to be empty'
          , 'expected ' + elToString(obj) + ' to not be empty');
      } else {
        _super.apply(this, arguments);
      }
    }
  });

  chai.Assertion.overwriteChainableMethod('length',
    function(_super) {
      return function(length) {
        var obj = flag(this, 'object');
        if (isNodeList(obj) || isHTMLElement(obj)) {
          var actualLength = obj.children ? obj.children.length : obj.length;
          this.assert(
              actualLength === length
            , 'expected ' + elToString(obj) + ' to have #{exp} children but it had #{act} children'
            , 'expected ' + elToString(obj) + ' to not have #{exp} children'
            , length
            , actualLength
          );
        } else {
          _super.apply(this, arguments);
        }
      }
    },
    function(_super) {
      return function() {
        _super.call(this);
      }
    }
  );


  chai.Assertion.overwriteMethod('match', function(_super) {
    return function(selector) {
      var obj = flag(this, 'object');
      if (isHTMLElement(obj)) {
        this.assert(
          obj.matches(selector)
          , 'expected ' + elToString(obj) + ' to match #{exp}'
          , 'expected ' + elToString(obj) + ' to not match #{exp}'
          , selector
        );
      } else if (isNodeList(obj)) {
        this.assert(
          (!!obj.length && Array.prototype.every.call(obj, function(el) { return el.matches(selector) }))
          , 'expected ' + elToString(obj) + ' to match #{exp}'
          , 'expected ' + elToString(obj) + ' to not match #{exp}'
          , selector
        );
      } else {
        _super.apply(this, arguments);
      }
    }
  });

  chai.Assertion.overwriteChainableMethod('contain',
    function(_super) {
      return function(subitem) {
        var obj = flag(this, 'object');
        if (isHTMLElement(obj)) {
          if (typeof subitem === 'string') {
            this.assert(
              !!obj.querySelector(subitem)
              , 'expected ' + elToString(obj) + ' to contain #{exp}'
              , 'expected ' + elToString(obj) + ' to not contain #{exp}'
              , subitem);
          } else {
            this.assert(
              obj.contains(subitem)
              , 'expected ' + elToString(obj) + ' to contain ' + elToString(subitem)
              , 'expected ' + elToString(obj) + ' to not contain ' + elToString(subitem));
          }
        } else {
          _super.apply(this, arguments);
        }
      }
    },
    function(_super) {
      return function() {
        _super.call(this);
      }
    }
  );

  chai.Assertion.addMethod('descendant', function(subitem) {
    var obj = flag(this, 'object'), actual = subitem;

    if (typeof subitem === 'string') {
      actual = obj.querySelector(subitem);
      this.assert(
        !!actual
        , 'expected ' + elToString(obj) + ' to have descendant #{exp}'
        , 'expected ' + elToString(obj) + ' to not have descendant #{exp}'
        , subitem);
    } else {
      this.assert(
        obj.contains(subitem)
        , 'expected ' + elToString(obj) + ' to contain ' + elToString(subitem)
        , 'expected ' + elToString(obj) + ' to not contain ' + elToString(subitem));
    }

    flag(this, 'object', actual);
  });

  chai.Assertion.addMethod('descendants', function(selector) {
    var obj = flag(this, 'object'),
        actual = obj.querySelectorAll(selector);
    this.assert(
      !!actual.length
      , 'expected ' + elToString(obj) + ' to have descendants #{exp}'
      , 'expected ' + elToString(obj) + ' to not have descendants #{exp}'
      , selector);
    flag(this, 'object', actual);
  });

  chai.Assertion.addProperty('displayed', function() {
    var el = flag(this, 'object'),
        actual = document.body.contains(el) ? window.getComputedStyle(el).display : el.style.display;

    this.assert(
      actual !== 'none'
      , 'expected ' + elToString(el) + ' to be displayed, but it was not'
      , 'expected ' + elToString(el) + ' to not be displayed, but it was as ' + actual
      , actual
    );
  });

  chai.Assertion.addProperty('visible', function() {
    var el = flag(this, 'object'),
        actual = document.body.contains(el) ? window.getComputedStyle(el).visibility : el.style.visibility;

    this.assert(
      actual !== 'hidden' && actual !== 'collapse'
      , 'expected ' + elToString(el) + ' to be visible, but it was ' + (actual === 'hidden' ? 'hidden' : 'collapsed')
      , 'expected ' + elToString(el) + ' to not be visible, but it was'
      , actual
    );
  });

  chai.Assertion.addMethod('tagName', function(tagName) {
    var el = flag(this, 'object'),
        actual = el.tagName;

    this.assert(
      actual.toUpperCase() === tagName.toUpperCase()
      , 'expected ' + elToString(el) + ' to have tagName ' + tagName + ', but it was ' + actual
      , 'expected ' + elToString(el) + ' to not have tagName ' + tagName + ', but it was ' + actual
      , actual
    );
  });

  chai.Assertion.addMethod('style', function (styleProp, styleValue) {
    var el = flag(this, 'object'),
        style = window.getComputedStyle(el),
        actual = style.getPropertyValue(styleProp).trim();

    this.assert(
      actual === styleValue
      , 'expected ' + elToString(el) + ' to have style property ' + styleProp + ' equal to ' + styleValue + ', but it was equal to ' + actual
      , 'expected ' + elToString(el) + ' to not have style property ' + styleProp + ' equal to ' + styleValue + ', but it was equal to ' + actual
      , actual
    );
  });

  chai.Assertion.overwriteProperty('focus', function() {
    return function () {
      var el = flag(this, 'object'), actual = el.ownerDocument.activeElement;

      this.assert(
        el === el.ownerDocument.activeElement
        , 'expected #{this} to have focus'
        , 'expected #{this} not to have focus'
        , el
        , actual
      );

    }
  });

  chai.Assertion.overwriteProperty('checked', function() {
    return function () {
      var el = flag(this, 'object');

      if(!(el instanceof HTMLInputElement && (el.type === 'checkbox' || el.type === 'radio'))) {
        throw new TypeError(elToString(el) + ' is not a checkbox or radio input');
      }

      this.assert(
        el.checked
        , 'expected ' + elToString(el) + ' to be checked'
        , 'expected ' + elToString(el) + ' to not be checked');
    }
  });
}));
});

function createCommonjsModule(fn) {
  var module = { exports: {} };
	return fn(module, module.exports), module.exports;
}

function commonjsRequire (path) {
	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}

var sinonChai = createCommonjsModule(function (module, exports) {
/* eslint-disable no-invalid-this */

(function (sinonChai) {
    // Module systems magic dance.

    /* istanbul ignore else */
    if (typeof commonjsRequire === "function" && 'object' === "object" && 'object' === "object") {
        // NodeJS
        module.exports = sinonChai;
    } else {
        // Other environment (usually <script> tag): plug in to global chai instance directly.
        /* global chai: false */
        chai.use(sinonChai);
    }
}(function (chai, utils) {
    var slice = Array.prototype.slice;

    function isSpy(putativeSpy) {
        return typeof putativeSpy === "function" &&
               typeof putativeSpy.getCall === "function" &&
               typeof putativeSpy.calledWithExactly === "function";
    }

    function timesInWords(count) {
        switch (count) {
            case 1: {
                return "once";
            }
            case 2: {
                return "twice";
            }
            case 3: {
                return "thrice";
            }
            default: {
                return (count || 0) + " times";
            }
        }
    }

    function isCall(putativeCall) {
        return putativeCall && isSpy(putativeCall.proxy);
    }

    function assertCanWorkWith(assertion) {
        if (!isSpy(assertion._obj) && !isCall(assertion._obj)) {
            throw new TypeError(utils.inspect(assertion._obj) + " is not a spy or a call to a spy!");
        }
    }

    function getMessages(spy, action, nonNegatedSuffix, always, args) {
        var verbPhrase = always ? "always have " : "have ";
        nonNegatedSuffix = nonNegatedSuffix || "";
        if (isSpy(spy.proxy)) {
            spy = spy.proxy;
        }

        function printfArray(array) {
            return spy.printf.apply(spy, array);
        }

        return {
            affirmative: function () {
                return printfArray(["expected %n to " + verbPhrase + action + nonNegatedSuffix].concat(args));
            },
            negative: function () {
                return printfArray(["expected %n to not " + verbPhrase + action].concat(args));
            }
        };
    }

    function sinonProperty(name, action, nonNegatedSuffix) {
        utils.addProperty(chai.Assertion.prototype, name, function () {
            assertCanWorkWith(this);

            var messages = getMessages(this._obj, action, nonNegatedSuffix, false);
            this.assert(this._obj[name], messages.affirmative, messages.negative);
        });
    }

    function sinonPropertyAsBooleanMethod(name, action, nonNegatedSuffix) {
        utils.addMethod(chai.Assertion.prototype, name, function (arg) {
            assertCanWorkWith(this);

            var messages = getMessages(this._obj, action, nonNegatedSuffix, false, [timesInWords(arg)]);
            this.assert(this._obj[name] === arg, messages.affirmative, messages.negative);
        });
    }

    function createSinonMethodHandler(sinonName, action, nonNegatedSuffix) {
        return function () {
            assertCanWorkWith(this);

            var alwaysSinonMethod = "always" + sinonName[0].toUpperCase() + sinonName.substring(1);
            var shouldBeAlways = utils.flag(this, "always") && typeof this._obj[alwaysSinonMethod] === "function";
            var sinonMethodName = shouldBeAlways ? alwaysSinonMethod : sinonName;

            var messages = getMessages(this._obj, action, nonNegatedSuffix, shouldBeAlways, slice.call(arguments));
            this.assert(
                this._obj[sinonMethodName].apply(this._obj, arguments),
                messages.affirmative,
                messages.negative
            );
        };
    }

    function sinonMethodAsProperty(name, action, nonNegatedSuffix) {
        var handler = createSinonMethodHandler(name, action, nonNegatedSuffix);
        utils.addProperty(chai.Assertion.prototype, name, handler);
    }

    function exceptionalSinonMethod(chaiName, sinonName, action, nonNegatedSuffix) {
        var handler = createSinonMethodHandler(sinonName, action, nonNegatedSuffix);
        utils.addMethod(chai.Assertion.prototype, chaiName, handler);
    }

    function sinonMethod(name, action, nonNegatedSuffix) {
        exceptionalSinonMethod(name, name, action, nonNegatedSuffix);
    }

    utils.addProperty(chai.Assertion.prototype, "always", function () {
        utils.flag(this, "always", true);
    });

    sinonProperty("called", "been called", " at least once, but it was never called");
    sinonPropertyAsBooleanMethod("callCount", "been called exactly %1", ", but it was called %c%C");
    sinonProperty("calledOnce", "been called exactly once", ", but it was called %c%C");
    sinonProperty("calledTwice", "been called exactly twice", ", but it was called %c%C");
    sinonProperty("calledThrice", "been called exactly thrice", ", but it was called %c%C");
    sinonMethodAsProperty("calledWithNew", "been called with new");
    sinonMethod("calledBefore", "been called before %1");
    sinonMethod("calledAfter", "been called after %1");
    sinonMethod("calledImmediatelyBefore", "been called immediately before %1");
    sinonMethod("calledImmediatelyAfter", "been called immediately after %1");
    sinonMethod("calledOn", "been called with %1 as this", ", but it was called with %t instead");
    sinonMethod("calledWith", "been called with arguments %*", "%D");
    sinonMethod("calledOnceWith", "been called exactly once with arguments %*", "%D");
    sinonMethod("calledWithExactly", "been called with exact arguments %*", "%D");
    sinonMethod("calledOnceWithExactly", "been called exactly once with exact arguments %*", "%D");
    sinonMethod("calledWithMatch", "been called with arguments matching %*", "%D");
    sinonMethod("returned", "returned %1");
    exceptionalSinonMethod("thrown", "threw", "thrown %1");
}));
});

// es module plugins

o$1.use(chaiDomDiff);
o$1.use(chaiA11yAxe);
o$1.use(chaiDom);
o$1.use(sinonChai);

/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const e$2=Symbol.for(""),l=t=>{if((null==t?void 0:t.r)===e$2)return null==t?void 0:t._$litStatic$},s=new Map,a=t=>(r,...e)=>{const o=e.length;let i,a;const n=[],u=[];let c,$=0,f=!1;for(;$<o;){for(c=r[$];$<o&&void 0!==(a=e[$],i=l(a));)c+=i+r[++$],f=!0;u.push(a),n.push(c),$++;}if($===o&&n.push(r[o]),f){const t=n.join("$$lit$$");void 0===(r=s.get(t))&&(n.raw=n,s.set(t,r=n)),e=u;}return t(r,...e)},n$1=a(y);

/**
 * Resolves after requestAnimationFrame.
 *
 * @example
 * await nextFrame();
 *
 * @returns {Promise<void>} Promise that resolved after requestAnimationFrame
 */
function nextFrame() {
  return new Promise(resolve => {
    requestAnimationFrame(() => resolve());
  });
}

const isDefinedPromise = action => typeof action === 'object' && Promise.resolve(action) === action;

/**
 * Awaits for "update complete promises" of elements
 * - for [lit-element](https://github.com/polymer/lit-element) that is `el.updateComplete`;
 * - for [stencil](https://github.com/ionic-team/stencil/) that is `el.componentOnReady()`;
 *
 * If none of those specfic Promise hooks are found, it will wait for one frame via
 * `await nextFrame()`.
 *
 * Ensures that ShadyDOM finished its job if available.
 *
 * @template {Element} T
 * @param {T} el
 * @returns {Promise<T>}
 */
async function elementUpdated(el) {
  let hasSpecificAwait = false;
  // @ts-ignore
  let update = el && el.updateComplete;
  if (isDefinedPromise(update)) {
    await update;
    hasSpecificAwait = true;
  }

  // @ts-ignore
  update = el && el.componentOnReady ? el.componentOnReady() : false;
  if (isDefinedPromise(update)) {
    await update;
    hasSpecificAwait = true;
  }

  if (!hasSpecificAwait) {
    await nextFrame();
  }

  // @ts-ignore
  if (window.ShadyDOM && typeof window.ShadyDOM.flush === 'function') {
    // @ts-ignore
    window.ShadyDOM.flush();
  }

  return el;
}

/** @type Array<Node> */
const cachedWrappers = [];

/**
 * Creates a wrapper as a direct child of `<body>` to put the tested element into.
 * Need to be in the DOM to test for example `connectedCallback()` on elements.
 *
 * @param {Element} [parentNode]
 * @returns {Element} wrapping node
 */
function fixtureWrapper(parentNode = document.createElement('div')) {
  document.body.appendChild(parentNode);
  cachedWrappers.push(parentNode);
  return parentNode;
}

/**
 * Cleans up all defined fixtures by removing the actual wrapper nodes.
 * Common usecase is at the end of each test.
 */
function fixtureCleanup() {
  if (cachedWrappers) {
    cachedWrappers.forEach(wrapper => {
      document.body.removeChild(wrapper);
    });
  }
  cachedWrappers.length = 0; // reset it like this as we can't reassign it
}

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t={ATTRIBUTE:1,CHILD:2,PROPERTY:3,BOOLEAN_ATTRIBUTE:4,EVENT:5,ELEMENT:6},e$1=t=>(...e)=>({_$litDirective$:t,values:e});class i{constructor(t){}get _$AU(){return this._$AM._$AU}_$AT(t,e,i){this._$Ct=t,this._$AM=e,this._$Ci=i;}_$AS(t,e){return this.update(t,e)}update(t,e){return this.render(...e)}}

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */class e extends i{constructor(i){if(super(i),this.it=b,i.type!==t.CHILD)throw Error(this.constructor.directiveName+"() can only be used in child bindings")}render(r){if(r===b||null==r)return this._t=void 0,this.it=r;if(r===x)return r;if("string"!=typeof r)throw Error(this.constructor.directiveName+"() called with a non-string value");if(r===this.it)return this._t;this.it=r;const s=[r];return s.raw=s,this._t={_$litType$:this.constructor.resultType,strings:s,values:[]}}}e.directiveName="unsafeHTML",e.resultType=1;const o=e$1(e);

/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const n=(o,l)=>void 0===l?void 0!==(null==o?void 0:o._$litType$):(null==o?void 0:o._$litType$)===l;

const isIterable = object => object != null && typeof object[Symbol.iterator] === 'function';

function isValidNonIterableRenderArg(x) {
  return (
    n(x) ||
    x instanceof Node ||
    typeof x === 'number' ||
    typeof x === 'boolean' ||
    typeof x === 'string'
  );
}

function isValidRenderArg(x) {
  return isIterable(x) ? [...x].every(isValidNonIterableRenderArg) : isValidNonIterableRenderArg(x);
}

/**
 * Node#nodeType enum
 * @readonly
 * @enum {number}
 */
const NODE_TYPES = Object.freeze({
  ELEMENT_NODE: 1,
  TEXT_NODE: 3,
  COMMENT_NODE: 8,
  DOCUMENT_FRAGMENT_NODE: 11,
});

const isUsefulNode = ({ nodeType, textContent }) => {
  switch (nodeType) {
    case NODE_TYPES.COMMENT_NODE:
      return false;
    case NODE_TYPES.TEXT_NODE:
      return textContent.trim();
    default:
      return true;
  }
};

/**
 * Setups an element synchronously from the provided lit-html template and puts it in the DOM.
 *
 * @template {Element} T - Is an element or a node
 * @param {import('./renderable').LitHTMLRenderable} template
 * @param {import('./fixture-no-side-effect.js').FixtureOptions} [options]
 * @param {import('./scopedElementsWrapper.js').ScopedElementsTemplateGetter} [getScopedElementsTemplate]
 * @returns {T}
 */
// eslint-disable-next-line default-param-last
function litFixtureSync(template, options = {}, getScopedElementsTemplate) {
  const wrapper = /** @type {HTMLElement} */ (fixtureWrapper(options.parentNode));
  const render = options.render ?? Z;

  render(
    options.scopedElements ? getScopedElementsTemplate(template, options.scopedElements) : template,
    wrapper,
  );

  if (n(template)) {
    return /** @type {T} */ (wrapper.firstElementChild);
  }
  const [node] = Array.from(wrapper.childNodes).filter(isUsefulNode);

  return /** @type {T} */ (node);
}

/**
 * Setups an element asynchronously from the provided lit-html template and puts it in the DOM.
 *
 * @template {Element} T - Is an element or a node
 * @param {import('./renderable').LitHTMLRenderable} template
 * @param {import('./fixture-no-side-effect.js').FixtureOptions} [options]
 * @returns {Promise<T>}
 */
async function litFixture(template, options = {}) {
  /** @type {import('./scopedElementsWrapper.js').ScopedElementsTemplateGetter|undefined} */
  const getScopedElementsTemplate = options.scopedElements
    ? await import('./scopedElementsWrapper-09fc1725.js').then(
        scopedElementWrapper => scopedElementWrapper.getScopedElementsTemplate,
      )
    : undefined;
  /** @type {T} */
  // NB: in the case of scopedElements, this is ScopedElementsTestWrapper, not T,
  // but that's only a small lie
  const el = litFixtureSync(template, options, getScopedElementsTemplate);
  await elementUpdated(el);

  if (options.scopedElements) {
    const [node] =
      /** @type {T[]} */
      (Array.from(el.shadowRoot.childNodes).filter(isUsefulNode));
    await elementUpdated(node);

    return node;
  }

  return el;
}

/**
 * Setups an element synchronously from the provided string template and puts it in the DOM.
 * Allows to specify properties via an object or a function taking the element as an argument.
 *
 * @template {Element} T - Is an element or a node
 * @param {string} template
 * @param {import('./fixture-no-side-effect.js').FixtureOptions} [options={}]
 * @returns {T}
 */
function stringFixtureSync(template, options = {}) {
  const parentNode = fixtureWrapper(options.parentNode);
  parentNode.innerHTML = template;
  return /** @type {T} */ (parentNode.children[0]);
}

/**
 * Setups an element asynchronously from the provided string template and puts it in the DOM.
 * Allows to specify properties via an object or a function taking the element as an argument.
 *
 * @template {Element} T - Is an element or a node
 * @param {string} template
 * @param {import('./fixture-no-side-effect.js').FixtureOptions} [options]
 * @returns {Promise<T>}
 */
async function stringFixture(template, options = {}) {
  if (options.scopedElements) {
    // @ts-ignore
    return litFixture(y`${o(template)}`, options);
  }

  const el = stringFixtureSync(template, options);
  await elementUpdated(el);
  // @ts-ignore
  return el;
}

/**
 * Renders a string/TemplateResult and puts it in the DOM via a fixtureWrapper.
 * By default fixture awaits the elements "update complete" Promise.
 * - for [lit-element](https://github.com/polymer/lit-element) that is `el.updateComplete`;
 * - for [stencil](https://github.com/ionic-team/stencil/) that is `el.componentOnReady()`;
 *
 * If none of those specfic Promise hooks are found, it will wait for one frame via
 * `await nextFrame()`.
 *
 * **Note**: this does not guarantee that the element is done rendering -
 * it just waits for the next JavaScript tick.
 *
 * @example
 * const el = await fixture('<my-el><span></span></my-el>');
 * expect(el.fullyRendered).to.be.true;
 *
 * @template {Element} T
 * @param {import('./renderable').LitHTMLRenderable} template Either a string or lit-html TemplateResult
 * @param {FixtureOptions} [options]
 * @returns {Promise<T>} A Promise that will resolve to the first child of the rendered DOM
 */
async function fixture(template, options) {
  if (typeof template === 'string') {
    return stringFixture(template, options);
  }
  if (!!options?.render || isValidRenderArg(template)) {
    return litFixture(template, options);
  }
  throw new Error('Invalid template provided - string or lit-html TemplateResult is supported');
}

/**
 * This registers the fixture cleanup as a side effect
 */
try {
  // we should not assume that our users load mocha types globally
  // @ts-ignore
  if ('afterEach' in window) {
    // @ts-ignore
    afterEach(() => {
      fixtureCleanup();
    });
  }
  // @ts-ignore
  if ('teardown' in window) {
    // @ts-ignore
    teardown(() => {
      fixtureCleanup();
    });
  }
} catch (error) {
  /* do nothing */
}

/* eslint-disable @typescript-eslint/ban-ts-comment */
// @ts-ignore
suite('my-element', () => {
    // @ts-ignore
    test('is defined', () => {
        const el = document.createElement('my-element');
        h.instanceOf(el, MyElement);
    });
    // @ts-ignore
    test('renders with default values', async () => {
        const el = await fixture(n$1 `<my-element></my-element>`);
        h.shadowDom.equal(el, `
      <h1>Hello, World!</h1>
      <button part="button">Click Count: 0</button>
      <slot></slot>
    `);
    });
    // @ts-ignore
    test('renders with a set name', async () => {
        const el = await fixture(n$1 `<my-element name="Test"></my-element>`);
        h.shadowDom.equal(el, `
      <h1>Hello, Test!</h1>
      <button part="button">Click Count: 0</button>
      <slot></slot>
    `);
    });
    // @ts-ignore
    test('handles a click', async () => {
        const el = (await fixture(n$1 `<my-element></my-element>`));
        const button = el.shadowRoot.querySelector('button');
        button.click();
        await el.updateComplete;
        h.shadowDom.equal(el, `
      <h1>Hello, World!</h1>
      <button part="button">Click Count: 1</button>
      <slot></slot>
    `);
    });
    // @ts-ignore
    test('styling applied', async () => {
        const el = (await fixture(n$1 `<my-element></my-element>`));
        await el.updateComplete;
        h.equal(getComputedStyle(el).paddingTop, '16px');
    });
});
